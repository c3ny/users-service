bc9bc5f91a4952fbadd74a50c5e9a537
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _testing = require("@nestjs/testing");
const _compareHashuseCase = require("./compareHash.useCase");
const _constants = require("../../../constants");
describe('CompareHashUseCase', ()=>{
    let useCase;
    let hashRepository;
    beforeEach(async ()=>{
        const mockHashRepository = {
            hash: jest.fn(),
            compare: jest.fn()
        };
        const module = await _testing.Test.createTestingModule({
            providers: [
                _compareHashuseCase.CompareHashUseCase,
                {
                    provide: _constants.HASH_REPOSITORY,
                    useValue: mockHashRepository
                }
            ]
        }).compile();
        useCase = module.get(_compareHashuseCase.CompareHashUseCase);
        hashRepository = module.get(_constants.HASH_REPOSITORY);
    });
    describe('execute', ()=>{
        it('should return true when password matches hash', ()=>{
            const params = {
                password: 'mySecretPassword123',
                hash: 'hashedPassword123'
            };
            hashRepository.compare.mockReturnValue(true);
            const result = useCase.execute(params);
            expect(result).toBe(true);
            expect(hashRepository.compare).toHaveBeenCalledWith(params.password, params.hash);
        });
        it('should return false when password does not match hash', ()=>{
            const params = {
                password: 'wrongPassword',
                hash: 'hashedPassword123'
            };
            hashRepository.compare.mockReturnValue(false);
            const result = useCase.execute(params);
            expect(result).toBe(false);
            expect(hashRepository.compare).toHaveBeenCalledWith(params.password, params.hash);
        });
        it('should handle empty password', ()=>{
            const params = {
                password: '',
                hash: 'hashedPassword123'
            };
            hashRepository.compare.mockReturnValue(false);
            const result = useCase.execute(params);
            expect(result).toBe(false);
            expect(hashRepository.compare).toHaveBeenCalledWith(params.password, params.hash);
        });
        it('should handle empty hash', ()=>{
            const params = {
                password: 'myPassword',
                hash: ''
            };
            hashRepository.compare.mockReturnValue(false);
            const result = useCase.execute(params);
            expect(result).toBe(false);
            expect(hashRepository.compare).toHaveBeenCalledWith(params.password, params.hash);
        });
        it('should handle both empty password and hash', ()=>{
            const params = {
                password: '',
                hash: ''
            };
            hashRepository.compare.mockReturnValue(true);
            const result = useCase.execute(params);
            expect(result).toBe(true);
            expect(hashRepository.compare).toHaveBeenCalledWith(params.password, params.hash);
        });
        it('should handle different password lengths', ()=>{
            const passwords = [
                'a',
                'short',
                'mediumLengthPassword123',
                'veryLongPasswordWithManyCharactersAndNumbers123456789'
            ];
            passwords.forEach((password, index)=>{
                const params = {
                    password,
                    hash: `hash_${index}`
                };
                const expectedResult = index % 2 === 0; // Alternate true/false
                hashRepository.compare.mockReturnValue(expectedResult);
                const result = useCase.execute(params);
                expect(result).toBe(expectedResult);
                expect(hashRepository.compare).toHaveBeenCalledWith(password, params.hash);
            });
        });
        it('should handle passwords with special characters', ()=>{
            const specialPasswords = [
                'password@123',
                'p@ssw0rd!',
                'mY$ecr3t#P@ssw0rd',
                'test!@#$%^&*()_+',
                'Ã Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«'
            ];
            specialPasswords.forEach((password, index)=>{
                const params = {
                    password,
                    hash: `special_hash_${index}`
                };
                hashRepository.compare.mockReturnValue(true);
                const result = useCase.execute(params);
                expect(result).toBe(true);
                expect(hashRepository.compare).toHaveBeenCalledWith(password, params.hash);
            });
        });
        it('should handle case sensitivity', ()=>{
            const testCases = [
                {
                    password: 'Password123',
                    hash: 'hash1',
                    expected: true
                },
                {
                    password: 'password123',
                    hash: 'hash1',
                    expected: false
                },
                {
                    password: 'PASSWORD123',
                    hash: 'hash1',
                    expected: false
                }
            ];
            testCases.forEach((testCase, index)=>{
                const params = {
                    password: testCase.password,
                    hash: testCase.hash
                };
                hashRepository.compare.mockReturnValue(testCase.expected);
                const result = useCase.execute(params);
                expect(result).toBe(testCase.expected);
                expect(hashRepository.compare).toHaveBeenCalledWith(testCase.password, testCase.hash);
            });
        });
        it('should handle Unicode characters', ()=>{
            const unicodePasswords = [
                'contraseÃ±a123',
                'Ð¿Ð°Ñ€Ð¾Ð»ÑŒ123',
                'å¯†ç 123',
                'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰123',
                'ðŸ”ðŸ”‘ðŸ›¡ï¸'
            ];
            unicodePasswords.forEach((password, index)=>{
                const params = {
                    password,
                    hash: `unicode_hash_${index}`
                };
                hashRepository.compare.mockReturnValue(true);
                const result = useCase.execute(params);
                expect(result).toBe(true);
                expect(hashRepository.compare).toHaveBeenCalledWith(password, params.hash);
            });
        });
        it('should handle passwords with spaces', ()=>{
            const passwordsWithSpaces = [
                'password with spaces',
                ' leading space',
                'trailing space ',
                '  multiple  spaces  '
            ];
            passwordsWithSpaces.forEach((password, index)=>{
                const params = {
                    password,
                    hash: `space_hash_${index}`
                };
                hashRepository.compare.mockReturnValue(true);
                const result = useCase.execute(params);
                expect(result).toBe(true);
                expect(hashRepository.compare).toHaveBeenCalledWith(password, params.hash);
            });
        });
        it('should handle repository errors gracefully', ()=>{
            const params = {
                password: 'testPassword',
                hash: 'testHash'
            };
            hashRepository.compare.mockImplementation(()=>{
                throw new Error('Hash comparison service unavailable');
            });
            expect(()=>useCase.execute(params)).toThrow('Hash comparison service unavailable');
            expect(hashRepository.compare).toHaveBeenCalledWith(params.password, params.hash);
        });
        it('should handle multiple comparison attempts with same credentials', ()=>{
            const params = {
                password: 'samePassword123',
                hash: 'sameHash123'
            };
            hashRepository.compare.mockReturnValue(true);
            const result1 = useCase.execute(params);
            const result2 = useCase.execute(params);
            const result3 = useCase.execute(params);
            expect(result1).toBe(true);
            expect(result2).toBe(true);
            expect(result3).toBe(true);
            expect(hashRepository.compare).toHaveBeenCalledTimes(3);
        });
        it('should handle concurrent comparison requests', ()=>{
            const testCases = [
                {
                    password: 'password1',
                    hash: 'hash1',
                    expected: true
                },
                {
                    password: 'password2',
                    hash: 'hash2',
                    expected: false
                },
                {
                    password: 'password3',
                    hash: 'hash3',
                    expected: true
                },
                {
                    password: 'password4',
                    hash: 'hash4',
                    expected: false
                },
                {
                    password: 'password5',
                    hash: 'hash5',
                    expected: true
                }
            ];
            testCases.forEach((testCase, index)=>{
                hashRepository.compare.mockReturnValueOnce(testCase.expected);
            });
            const results = testCases.map((testCase)=>useCase.execute({
                    password: testCase.password,
                    hash: testCase.hash
                }));
            results.forEach((result, index)=>{
                expect(result).toBe(testCases[index].expected);
            });
            expect(hashRepository.compare).toHaveBeenCalledTimes(5);
        });
        it('should handle authentication scenarios', ()=>{
            const authenticationTests = [
                {
                    scenario: 'Valid login',
                    password: 'userPassword123',
                    hash: 'validHashForUser123',
                    expected: true
                },
                {
                    scenario: 'Invalid password',
                    password: 'wrongPassword',
                    hash: 'validHashForUser123',
                    expected: false
                },
                {
                    scenario: 'Brute force attempt',
                    password: '123456',
                    hash: 'validHashForUser123',
                    expected: false
                }
            ];
            authenticationTests.forEach((test)=>{
                const params = {
                    password: test.password,
                    hash: test.hash
                };
                hashRepository.compare.mockReturnValue(test.expected);
                const result = useCase.execute(params);
                expect(result).toBe(test.expected);
                expect(hashRepository.compare).toHaveBeenCalledWith(test.password, test.hash);
            });
        });
        it('should handle edge case characters', ()=>{
            const edgeCases = [
                {
                    password: '\n',
                    hash: 'newline_hash'
                },
                {
                    password: '\t',
                    hash: 'tab_hash'
                },
                {
                    password: '\r',
                    hash: 'carriage_return_hash'
                },
                {
                    password: '\0',
                    hash: 'null_char_hash'
                },
                {
                    password: '\\',
                    hash: 'backslash_hash'
                },
                {
                    password: '"',
                    hash: 'quote_hash'
                },
                {
                    password: "'",
                    hash: 'single_quote_hash'
                }
            ];
            edgeCases.forEach((edgeCase, index)=>{
                const params = {
                    password: edgeCase.password,
                    hash: edgeCase.hash
                };
                const expected = index % 2 === 0;
                hashRepository.compare.mockReturnValue(expected);
                const result = useCase.execute(params);
                expect(result).toBe(expected);
                expect(hashRepository.compare).toHaveBeenCalledWith(edgeCase.password, edgeCase.hash);
            });
        });
        it('should handle very long passwords and hashes', ()=>{
            const veryLongPassword = 'a'.repeat(10000); // 10,000 characters
            const veryLongHash = 'h'.repeat(10000); // 10,000 characters
            const params = {
                password: veryLongPassword,
                hash: veryLongHash
            };
            hashRepository.compare.mockReturnValue(true);
            const result = useCase.execute(params);
            expect(result).toBe(true);
            expect(hashRepository.compare).toHaveBeenCalledWith(veryLongPassword, veryLongHash);
        });
        it('should handle common attack patterns', ()=>{
            const attackPatterns = [
                {
                    password: 'admin',
                    hash: 'user_hash',
                    expected: false
                },
                {
                    password: 'password',
                    hash: 'user_hash',
                    expected: false
                },
                {
                    password: '123456',
                    hash: 'user_hash',
                    expected: false
                },
                {
                    password: 'qwerty',
                    hash: 'user_hash',
                    expected: false
                },
                {
                    password: '',
                    hash: 'user_hash',
                    expected: false
                }
            ];
            attackPatterns.forEach((pattern)=>{
                const params = {
                    password: pattern.password,
                    hash: pattern.hash
                };
                hashRepository.compare.mockReturnValue(pattern.expected);
                const result = useCase.execute(params);
                expect(result).toBe(pattern.expected);
                expect(hashRepository.compare).toHaveBeenCalledWith(pattern.password, pattern.hash);
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy95c3JhZWxtb3Jlbm8vRG9jdW1lbnRzL2NvZGVzL2ZhdGVjL3Nhbmd1ZS1zb2xpZGFyaW8vdXNlcnMtc2VydmljZS9zcmMvbW9kdWxlcy9IYXNoL2FwcGxpY2F0aW9uL3BvcnRzL2luL2NvbXBhcmVIYXNoLnVzZUNhc2Uuc3BlYy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXN0LCBUZXN0aW5nTW9kdWxlIH0gZnJvbSAnQG5lc3Rqcy90ZXN0aW5nJztcbmltcG9ydCB7XG4gIENvbXBhcmVIYXNoVXNlQ2FzZSxcbiAgQ29tcGFyZUhhc2hVc2VDYXNlUGFyYW1zLFxufSBmcm9tICcuL2NvbXBhcmVIYXNoLnVzZUNhc2UnO1xuaW1wb3J0IHsgSGFzaFJlcG9zaXRvcnlQb3J0IH0gZnJvbSAnLi4vb3V0L2hhc2gtcmVwb3NpdG9yeS5wb3J0JztcbmltcG9ydCB7IEhBU0hfUkVQT1NJVE9SWSB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cyc7XG5cbmRlc2NyaWJlKCdDb21wYXJlSGFzaFVzZUNhc2UnLCAoKSA9PiB7XG4gIGxldCB1c2VDYXNlOiBDb21wYXJlSGFzaFVzZUNhc2U7XG4gIGxldCBoYXNoUmVwb3NpdG9yeTogamVzdC5Nb2NrZWQ8SGFzaFJlcG9zaXRvcnlQb3J0PjtcblxuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2NrSGFzaFJlcG9zaXRvcnkgPSB7XG4gICAgICBoYXNoOiBqZXN0LmZuKCksXG4gICAgICBjb21wYXJlOiBqZXN0LmZuKCksXG4gICAgfTtcblxuICAgIGNvbnN0IG1vZHVsZTogVGVzdGluZ01vZHVsZSA9IGF3YWl0IFRlc3QuY3JlYXRlVGVzdGluZ01vZHVsZSh7XG4gICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgQ29tcGFyZUhhc2hVc2VDYXNlLFxuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogSEFTSF9SRVBPU0lUT1JZLFxuICAgICAgICAgIHVzZVZhbHVlOiBtb2NrSGFzaFJlcG9zaXRvcnksXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pLmNvbXBpbGUoKTtcblxuICAgIHVzZUNhc2UgPSBtb2R1bGUuZ2V0PENvbXBhcmVIYXNoVXNlQ2FzZT4oQ29tcGFyZUhhc2hVc2VDYXNlKTtcbiAgICBoYXNoUmVwb3NpdG9yeSA9IG1vZHVsZS5nZXQoSEFTSF9SRVBPU0lUT1JZKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2V4ZWN1dGUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHBhc3N3b3JkIG1hdGNoZXMgaGFzaCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhcmFtczogQ29tcGFyZUhhc2hVc2VDYXNlUGFyYW1zID0ge1xuICAgICAgICBwYXNzd29yZDogJ215U2VjcmV0UGFzc3dvcmQxMjMnLFxuICAgICAgICBoYXNoOiAnaGFzaGVkUGFzc3dvcmQxMjMnLFxuICAgICAgfTtcblxuICAgICAgaGFzaFJlcG9zaXRvcnkuY29tcGFyZS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZUNhc2UuZXhlY3V0ZShwYXJhbXMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGhhc2hSZXBvc2l0b3J5LmNvbXBhcmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBwYXJhbXMucGFzc3dvcmQsXG4gICAgICAgIHBhcmFtcy5oYXNoLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gcGFzc3dvcmQgZG9lcyBub3QgbWF0Y2ggaGFzaCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhcmFtczogQ29tcGFyZUhhc2hVc2VDYXNlUGFyYW1zID0ge1xuICAgICAgICBwYXNzd29yZDogJ3dyb25nUGFzc3dvcmQnLFxuICAgICAgICBoYXNoOiAnaGFzaGVkUGFzc3dvcmQxMjMnLFxuICAgICAgfTtcblxuICAgICAgaGFzaFJlcG9zaXRvcnkuY29tcGFyZS5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSB1c2VDYXNlLmV4ZWN1dGUocGFyYW1zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoaGFzaFJlcG9zaXRvcnkuY29tcGFyZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIHBhcmFtcy5wYXNzd29yZCxcbiAgICAgICAgcGFyYW1zLmhhc2gsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgcGFzc3dvcmQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXJhbXM6IENvbXBhcmVIYXNoVXNlQ2FzZVBhcmFtcyA9IHtcbiAgICAgICAgcGFzc3dvcmQ6ICcnLFxuICAgICAgICBoYXNoOiAnaGFzaGVkUGFzc3dvcmQxMjMnLFxuICAgICAgfTtcblxuICAgICAgaGFzaFJlcG9zaXRvcnkuY29tcGFyZS5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSB1c2VDYXNlLmV4ZWN1dGUocGFyYW1zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoaGFzaFJlcG9zaXRvcnkuY29tcGFyZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIHBhcmFtcy5wYXNzd29yZCxcbiAgICAgICAgcGFyYW1zLmhhc2gsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgaGFzaCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhcmFtczogQ29tcGFyZUhhc2hVc2VDYXNlUGFyYW1zID0ge1xuICAgICAgICBwYXNzd29yZDogJ215UGFzc3dvcmQnLFxuICAgICAgICBoYXNoOiAnJyxcbiAgICAgIH07XG5cbiAgICAgIGhhc2hSZXBvc2l0b3J5LmNvbXBhcmUubW9ja1JldHVyblZhbHVlKGZhbHNlKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gdXNlQ2FzZS5leGVjdXRlKHBhcmFtcyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGhhc2hSZXBvc2l0b3J5LmNvbXBhcmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBwYXJhbXMucGFzc3dvcmQsXG4gICAgICAgIHBhcmFtcy5oYXNoLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGJvdGggZW1wdHkgcGFzc3dvcmQgYW5kIGhhc2gnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXJhbXM6IENvbXBhcmVIYXNoVXNlQ2FzZVBhcmFtcyA9IHtcbiAgICAgICAgcGFzc3dvcmQ6ICcnLFxuICAgICAgICBoYXNoOiAnJyxcbiAgICAgIH07XG5cbiAgICAgIGhhc2hSZXBvc2l0b3J5LmNvbXBhcmUubW9ja1JldHVyblZhbHVlKHRydWUpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSB1c2VDYXNlLmV4ZWN1dGUocGFyYW1zKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChoYXNoUmVwb3NpdG9yeS5jb21wYXJlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgcGFyYW1zLnBhc3N3b3JkLFxuICAgICAgICBwYXJhbXMuaGFzaCxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkaWZmZXJlbnQgcGFzc3dvcmQgbGVuZ3RocycsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhc3N3b3JkcyA9IFtcbiAgICAgICAgJ2EnLCAvLyBTaW5nbGUgY2hhcmFjdGVyXG4gICAgICAgICdzaG9ydCcsIC8vIFNob3J0IHBhc3N3b3JkXG4gICAgICAgICdtZWRpdW1MZW5ndGhQYXNzd29yZDEyMycsIC8vIE1lZGl1bSBwYXNzd29yZFxuICAgICAgICAndmVyeUxvbmdQYXNzd29yZFdpdGhNYW55Q2hhcmFjdGVyc0FuZE51bWJlcnMxMjM0NTY3ODknLCAvLyBMb25nIHBhc3N3b3JkXG4gICAgICBdO1xuXG4gICAgICBwYXNzd29yZHMuZm9yRWFjaCgocGFzc3dvcmQsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFtczogQ29tcGFyZUhhc2hVc2VDYXNlUGFyYW1zID0ge1xuICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgIGhhc2g6IGBoYXNoXyR7aW5kZXh9YCxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBleHBlY3RlZFJlc3VsdCA9IGluZGV4ICUgMiA9PT0gMDsgLy8gQWx0ZXJuYXRlIHRydWUvZmFsc2VcbiAgICAgICAgaGFzaFJlcG9zaXRvcnkuY29tcGFyZS5tb2NrUmV0dXJuVmFsdWUoZXhwZWN0ZWRSZXN1bHQpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZUNhc2UuZXhlY3V0ZShwYXJhbXMpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZXhwZWN0ZWRSZXN1bHQpO1xuICAgICAgICBleHBlY3QoaGFzaFJlcG9zaXRvcnkuY29tcGFyZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgcGFyYW1zLmhhc2gsXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHBhc3N3b3JkcyB3aXRoIHNwZWNpYWwgY2hhcmFjdGVycycsICgpID0+IHtcbiAgICAgIGNvbnN0IHNwZWNpYWxQYXNzd29yZHMgPSBbXG4gICAgICAgICdwYXNzd29yZEAxMjMnLFxuICAgICAgICAncEBzc3cwcmQhJyxcbiAgICAgICAgJ21ZJGVjcjN0I1BAc3N3MHJkJyxcbiAgICAgICAgJ3Rlc3QhQCMkJV4mKigpXysnLFxuICAgICAgICAnw6DDocOiw6PDpMOlw6bDp8Oow6nDqsOrJyxcbiAgICAgIF07XG5cbiAgICAgIHNwZWNpYWxQYXNzd29yZHMuZm9yRWFjaCgocGFzc3dvcmQsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFtczogQ29tcGFyZUhhc2hVc2VDYXNlUGFyYW1zID0ge1xuICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgIGhhc2g6IGBzcGVjaWFsX2hhc2hfJHtpbmRleH1gLFxuICAgICAgICB9O1xuXG4gICAgICAgIGhhc2hSZXBvc2l0b3J5LmNvbXBhcmUubW9ja1JldHVyblZhbHVlKHRydWUpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZUNhc2UuZXhlY3V0ZShwYXJhbXMpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChoYXNoUmVwb3NpdG9yeS5jb21wYXJlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICBwYXJhbXMuaGFzaCxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2FzZSBzZW5zaXRpdml0eScsICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDYXNlcyA9IFtcbiAgICAgICAgeyBwYXNzd29yZDogJ1Bhc3N3b3JkMTIzJywgaGFzaDogJ2hhc2gxJywgZXhwZWN0ZWQ6IHRydWUgfSxcbiAgICAgICAgeyBwYXNzd29yZDogJ3Bhc3N3b3JkMTIzJywgaGFzaDogJ2hhc2gxJywgZXhwZWN0ZWQ6IGZhbHNlIH0sXG4gICAgICAgIHsgcGFzc3dvcmQ6ICdQQVNTV09SRDEyMycsIGhhc2g6ICdoYXNoMScsIGV4cGVjdGVkOiBmYWxzZSB9LFxuICAgICAgXTtcblxuICAgICAgdGVzdENhc2VzLmZvckVhY2goKHRlc3RDYXNlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJhbXM6IENvbXBhcmVIYXNoVXNlQ2FzZVBhcmFtcyA9IHtcbiAgICAgICAgICBwYXNzd29yZDogdGVzdENhc2UucGFzc3dvcmQsXG4gICAgICAgICAgaGFzaDogdGVzdENhc2UuaGFzaCxcbiAgICAgICAgfTtcblxuICAgICAgICBoYXNoUmVwb3NpdG9yeS5jb21wYXJlLm1vY2tSZXR1cm5WYWx1ZSh0ZXN0Q2FzZS5leHBlY3RlZCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdXNlQ2FzZS5leGVjdXRlKHBhcmFtcyk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0ZXN0Q2FzZS5leHBlY3RlZCk7XG4gICAgICAgIGV4cGVjdChoYXNoUmVwb3NpdG9yeS5jb21wYXJlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICB0ZXN0Q2FzZS5wYXNzd29yZCxcbiAgICAgICAgICB0ZXN0Q2FzZS5oYXNoLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBVbmljb2RlIGNoYXJhY3RlcnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB1bmljb2RlUGFzc3dvcmRzID0gW1xuICAgICAgICAnY29udHJhc2XDsWExMjMnLCAvLyBTcGFuaXNoXG4gICAgICAgICfQv9Cw0YDQvtC70YwxMjMnLCAvLyBSdXNzaWFuXG4gICAgICAgICflr4bnoIExMjMnLCAvLyBDaGluZXNlXG4gICAgICAgICfjg5Hjgrnjg6/jg7zjg4kxMjMnLCAvLyBKYXBhbmVzZVxuICAgICAgICAn8J+UkPCflJHwn5uh77iPJywgLy8gRW1vamlzXG4gICAgICBdO1xuXG4gICAgICB1bmljb2RlUGFzc3dvcmRzLmZvckVhY2goKHBhc3N3b3JkLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJhbXM6IENvbXBhcmVIYXNoVXNlQ2FzZVBhcmFtcyA9IHtcbiAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICBoYXNoOiBgdW5pY29kZV9oYXNoXyR7aW5kZXh9YCxcbiAgICAgICAgfTtcblxuICAgICAgICBoYXNoUmVwb3NpdG9yeS5jb21wYXJlLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB1c2VDYXNlLmV4ZWN1dGUocGFyYW1zKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QoaGFzaFJlcG9zaXRvcnkuY29tcGFyZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgcGFyYW1zLmhhc2gsXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHBhc3N3b3JkcyB3aXRoIHNwYWNlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhc3N3b3Jkc1dpdGhTcGFjZXMgPSBbXG4gICAgICAgICdwYXNzd29yZCB3aXRoIHNwYWNlcycsXG4gICAgICAgICcgbGVhZGluZyBzcGFjZScsXG4gICAgICAgICd0cmFpbGluZyBzcGFjZSAnLFxuICAgICAgICAnICBtdWx0aXBsZSAgc3BhY2VzICAnLFxuICAgICAgXTtcblxuICAgICAgcGFzc3dvcmRzV2l0aFNwYWNlcy5mb3JFYWNoKChwYXNzd29yZCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zOiBDb21wYXJlSGFzaFVzZUNhc2VQYXJhbXMgPSB7XG4gICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgaGFzaDogYHNwYWNlX2hhc2hfJHtpbmRleH1gLFxuICAgICAgICB9O1xuXG4gICAgICAgIGhhc2hSZXBvc2l0b3J5LmNvbXBhcmUubW9ja1JldHVyblZhbHVlKHRydWUpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZUNhc2UuZXhlY3V0ZShwYXJhbXMpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChoYXNoUmVwb3NpdG9yeS5jb21wYXJlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICBwYXJhbXMuaGFzaCxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmVwb3NpdG9yeSBlcnJvcnMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhcmFtczogQ29tcGFyZUhhc2hVc2VDYXNlUGFyYW1zID0ge1xuICAgICAgICBwYXNzd29yZDogJ3Rlc3RQYXNzd29yZCcsXG4gICAgICAgIGhhc2g6ICd0ZXN0SGFzaCcsXG4gICAgICB9O1xuXG4gICAgICBoYXNoUmVwb3NpdG9yeS5jb21wYXJlLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBjb21wYXJpc29uIHNlcnZpY2UgdW5hdmFpbGFibGUnKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoKCkgPT4gdXNlQ2FzZS5leGVjdXRlKHBhcmFtcykpLnRvVGhyb3coXG4gICAgICAgICdIYXNoIGNvbXBhcmlzb24gc2VydmljZSB1bmF2YWlsYWJsZScsXG4gICAgICApO1xuICAgICAgZXhwZWN0KGhhc2hSZXBvc2l0b3J5LmNvbXBhcmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBwYXJhbXMucGFzc3dvcmQsXG4gICAgICAgIHBhcmFtcy5oYXNoLFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG11bHRpcGxlIGNvbXBhcmlzb24gYXR0ZW1wdHMgd2l0aCBzYW1lIGNyZWRlbnRpYWxzJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGFyYW1zOiBDb21wYXJlSGFzaFVzZUNhc2VQYXJhbXMgPSB7XG4gICAgICAgIHBhc3N3b3JkOiAnc2FtZVBhc3N3b3JkMTIzJyxcbiAgICAgICAgaGFzaDogJ3NhbWVIYXNoMTIzJyxcbiAgICAgIH07XG5cbiAgICAgIGhhc2hSZXBvc2l0b3J5LmNvbXBhcmUubW9ja1JldHVyblZhbHVlKHRydWUpO1xuXG4gICAgICBjb25zdCByZXN1bHQxID0gdXNlQ2FzZS5leGVjdXRlKHBhcmFtcyk7XG4gICAgICBjb25zdCByZXN1bHQyID0gdXNlQ2FzZS5leGVjdXRlKHBhcmFtcyk7XG4gICAgICBjb25zdCByZXN1bHQzID0gdXNlQ2FzZS5leGVjdXRlKHBhcmFtcyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQxKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdDIpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0MykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChoYXNoUmVwb3NpdG9yeS5jb21wYXJlKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb25jdXJyZW50IGNvbXBhcmlzb24gcmVxdWVzdHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Q2FzZXMgPSBbXG4gICAgICAgIHsgcGFzc3dvcmQ6ICdwYXNzd29yZDEnLCBoYXNoOiAnaGFzaDEnLCBleHBlY3RlZDogdHJ1ZSB9LFxuICAgICAgICB7IHBhc3N3b3JkOiAncGFzc3dvcmQyJywgaGFzaDogJ2hhc2gyJywgZXhwZWN0ZWQ6IGZhbHNlIH0sXG4gICAgICAgIHsgcGFzc3dvcmQ6ICdwYXNzd29yZDMnLCBoYXNoOiAnaGFzaDMnLCBleHBlY3RlZDogdHJ1ZSB9LFxuICAgICAgICB7IHBhc3N3b3JkOiAncGFzc3dvcmQ0JywgaGFzaDogJ2hhc2g0JywgZXhwZWN0ZWQ6IGZhbHNlIH0sXG4gICAgICAgIHsgcGFzc3dvcmQ6ICdwYXNzd29yZDUnLCBoYXNoOiAnaGFzaDUnLCBleHBlY3RlZDogdHJ1ZSB9LFxuICAgICAgXTtcblxuICAgICAgdGVzdENhc2VzLmZvckVhY2goKHRlc3RDYXNlLCBpbmRleCkgPT4ge1xuICAgICAgICBoYXNoUmVwb3NpdG9yeS5jb21wYXJlLm1vY2tSZXR1cm5WYWx1ZU9uY2UodGVzdENhc2UuZXhwZWN0ZWQpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB0ZXN0Q2FzZXMubWFwKCh0ZXN0Q2FzZSkgPT5cbiAgICAgICAgdXNlQ2FzZS5leGVjdXRlKHsgcGFzc3dvcmQ6IHRlc3RDYXNlLnBhc3N3b3JkLCBoYXNoOiB0ZXN0Q2FzZS5oYXNoIH0pLFxuICAgICAgKTtcblxuICAgICAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodGVzdENhc2VzW2luZGV4XS5leHBlY3RlZCk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGhhc2hSZXBvc2l0b3J5LmNvbXBhcmUpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyg1KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGF1dGhlbnRpY2F0aW9uIHNjZW5hcmlvcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGF1dGhlbnRpY2F0aW9uVGVzdHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBzY2VuYXJpbzogJ1ZhbGlkIGxvZ2luJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3VzZXJQYXNzd29yZDEyMycsXG4gICAgICAgICAgaGFzaDogJ3ZhbGlkSGFzaEZvclVzZXIxMjMnLFxuICAgICAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgc2NlbmFyaW86ICdJbnZhbGlkIHBhc3N3b3JkJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3dyb25nUGFzc3dvcmQnLFxuICAgICAgICAgIGhhc2g6ICd2YWxpZEhhc2hGb3JVc2VyMTIzJyxcbiAgICAgICAgICBleHBlY3RlZDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzY2VuYXJpbzogJ0JydXRlIGZvcmNlIGF0dGVtcHQnLFxuICAgICAgICAgIHBhc3N3b3JkOiAnMTIzNDU2JyxcbiAgICAgICAgICBoYXNoOiAndmFsaWRIYXNoRm9yVXNlcjEyMycsXG4gICAgICAgICAgZXhwZWN0ZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgYXV0aGVudGljYXRpb25UZXN0cy5mb3JFYWNoKCh0ZXN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFtczogQ29tcGFyZUhhc2hVc2VDYXNlUGFyYW1zID0ge1xuICAgICAgICAgIHBhc3N3b3JkOiB0ZXN0LnBhc3N3b3JkLFxuICAgICAgICAgIGhhc2g6IHRlc3QuaGFzaCxcbiAgICAgICAgfTtcblxuICAgICAgICBoYXNoUmVwb3NpdG9yeS5jb21wYXJlLm1vY2tSZXR1cm5WYWx1ZSh0ZXN0LmV4cGVjdGVkKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB1c2VDYXNlLmV4ZWN1dGUocGFyYW1zKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRlc3QuZXhwZWN0ZWQpO1xuICAgICAgICBleHBlY3QoaGFzaFJlcG9zaXRvcnkuY29tcGFyZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgdGVzdC5wYXNzd29yZCxcbiAgICAgICAgICB0ZXN0Lmhhc2gsXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVkZ2UgY2FzZSBjaGFyYWN0ZXJzJywgKCkgPT4ge1xuICAgICAgY29uc3QgZWRnZUNhc2VzID0gW1xuICAgICAgICB7IHBhc3N3b3JkOiAnXFxuJywgaGFzaDogJ25ld2xpbmVfaGFzaCcgfSxcbiAgICAgICAgeyBwYXNzd29yZDogJ1xcdCcsIGhhc2g6ICd0YWJfaGFzaCcgfSxcbiAgICAgICAgeyBwYXNzd29yZDogJ1xccicsIGhhc2g6ICdjYXJyaWFnZV9yZXR1cm5faGFzaCcgfSxcbiAgICAgICAgeyBwYXNzd29yZDogJ1xcMCcsIGhhc2g6ICdudWxsX2NoYXJfaGFzaCcgfSxcbiAgICAgICAgeyBwYXNzd29yZDogJ1xcXFwnLCBoYXNoOiAnYmFja3NsYXNoX2hhc2gnIH0sXG4gICAgICAgIHsgcGFzc3dvcmQ6ICdcIicsIGhhc2g6ICdxdW90ZV9oYXNoJyB9LFxuICAgICAgICB7IHBhc3N3b3JkOiBcIidcIiwgaGFzaDogJ3NpbmdsZV9xdW90ZV9oYXNoJyB9LFxuICAgICAgXTtcblxuICAgICAgZWRnZUNhc2VzLmZvckVhY2goKGVkZ2VDYXNlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJhbXM6IENvbXBhcmVIYXNoVXNlQ2FzZVBhcmFtcyA9IHtcbiAgICAgICAgICBwYXNzd29yZDogZWRnZUNhc2UucGFzc3dvcmQsXG4gICAgICAgICAgaGFzaDogZWRnZUNhc2UuaGFzaCxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBleHBlY3RlZCA9IGluZGV4ICUgMiA9PT0gMDtcbiAgICAgICAgaGFzaFJlcG9zaXRvcnkuY29tcGFyZS5tb2NrUmV0dXJuVmFsdWUoZXhwZWN0ZWQpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZUNhc2UuZXhlY3V0ZShwYXJhbXMpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZXhwZWN0ZWQpO1xuICAgICAgICBleHBlY3QoaGFzaFJlcG9zaXRvcnkuY29tcGFyZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgZWRnZUNhc2UucGFzc3dvcmQsXG4gICAgICAgICAgZWRnZUNhc2UuaGFzaCxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdmVyeSBsb25nIHBhc3N3b3JkcyBhbmQgaGFzaGVzJywgKCkgPT4ge1xuICAgICAgY29uc3QgdmVyeUxvbmdQYXNzd29yZCA9ICdhJy5yZXBlYXQoMTAwMDApOyAvLyAxMCwwMDAgY2hhcmFjdGVyc1xuICAgICAgY29uc3QgdmVyeUxvbmdIYXNoID0gJ2gnLnJlcGVhdCgxMDAwMCk7IC8vIDEwLDAwMCBjaGFyYWN0ZXJzXG5cbiAgICAgIGNvbnN0IHBhcmFtczogQ29tcGFyZUhhc2hVc2VDYXNlUGFyYW1zID0ge1xuICAgICAgICBwYXNzd29yZDogdmVyeUxvbmdQYXNzd29yZCxcbiAgICAgICAgaGFzaDogdmVyeUxvbmdIYXNoLFxuICAgICAgfTtcblxuICAgICAgaGFzaFJlcG9zaXRvcnkuY29tcGFyZS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZUNhc2UuZXhlY3V0ZShwYXJhbXMpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGhhc2hSZXBvc2l0b3J5LmNvbXBhcmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICB2ZXJ5TG9uZ1Bhc3N3b3JkLFxuICAgICAgICB2ZXJ5TG9uZ0hhc2gsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29tbW9uIGF0dGFjayBwYXR0ZXJucycsICgpID0+IHtcbiAgICAgIGNvbnN0IGF0dGFja1BhdHRlcm5zID0gW1xuICAgICAgICB7IHBhc3N3b3JkOiAnYWRtaW4nLCBoYXNoOiAndXNlcl9oYXNoJywgZXhwZWN0ZWQ6IGZhbHNlIH0sXG4gICAgICAgIHsgcGFzc3dvcmQ6ICdwYXNzd29yZCcsIGhhc2g6ICd1c2VyX2hhc2gnLCBleHBlY3RlZDogZmFsc2UgfSxcbiAgICAgICAgeyBwYXNzd29yZDogJzEyMzQ1NicsIGhhc2g6ICd1c2VyX2hhc2gnLCBleHBlY3RlZDogZmFsc2UgfSxcbiAgICAgICAgeyBwYXNzd29yZDogJ3F3ZXJ0eScsIGhhc2g6ICd1c2VyX2hhc2gnLCBleHBlY3RlZDogZmFsc2UgfSxcbiAgICAgICAgeyBwYXNzd29yZDogJycsIGhhc2g6ICd1c2VyX2hhc2gnLCBleHBlY3RlZDogZmFsc2UgfSwgLy8gRW1wdHkgcGFzc3dvcmQgYXR0YWNrXG4gICAgICBdO1xuXG4gICAgICBhdHRhY2tQYXR0ZXJucy5mb3JFYWNoKChwYXR0ZXJuKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFtczogQ29tcGFyZUhhc2hVc2VDYXNlUGFyYW1zID0ge1xuICAgICAgICAgIHBhc3N3b3JkOiBwYXR0ZXJuLnBhc3N3b3JkLFxuICAgICAgICAgIGhhc2g6IHBhdHRlcm4uaGFzaCxcbiAgICAgICAgfTtcblxuICAgICAgICBoYXNoUmVwb3NpdG9yeS5jb21wYXJlLm1vY2tSZXR1cm5WYWx1ZShwYXR0ZXJuLmV4cGVjdGVkKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB1c2VDYXNlLmV4ZWN1dGUocGFyYW1zKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKHBhdHRlcm4uZXhwZWN0ZWQpO1xuICAgICAgICBleHBlY3QoaGFzaFJlcG9zaXRvcnkuY29tcGFyZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgcGF0dGVybi5wYXNzd29yZCxcbiAgICAgICAgICBwYXR0ZXJuLmhhc2gsXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsInVzZUNhc2UiLCJoYXNoUmVwb3NpdG9yeSIsImJlZm9yZUVhY2giLCJtb2NrSGFzaFJlcG9zaXRvcnkiLCJoYXNoIiwiamVzdCIsImZuIiwiY29tcGFyZSIsIm1vZHVsZSIsIlRlc3QiLCJjcmVhdGVUZXN0aW5nTW9kdWxlIiwicHJvdmlkZXJzIiwiQ29tcGFyZUhhc2hVc2VDYXNlIiwicHJvdmlkZSIsIkhBU0hfUkVQT1NJVE9SWSIsInVzZVZhbHVlIiwiY29tcGlsZSIsImdldCIsIml0IiwicGFyYW1zIiwicGFzc3dvcmQiLCJtb2NrUmV0dXJuVmFsdWUiLCJyZXN1bHQiLCJleGVjdXRlIiwiZXhwZWN0IiwidG9CZSIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwicGFzc3dvcmRzIiwiZm9yRWFjaCIsImluZGV4IiwiZXhwZWN0ZWRSZXN1bHQiLCJzcGVjaWFsUGFzc3dvcmRzIiwidGVzdENhc2VzIiwiZXhwZWN0ZWQiLCJ0ZXN0Q2FzZSIsInVuaWNvZGVQYXNzd29yZHMiLCJwYXNzd29yZHNXaXRoU3BhY2VzIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiRXJyb3IiLCJ0b1Rocm93IiwicmVzdWx0MSIsInJlc3VsdDIiLCJyZXN1bHQzIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwibW9ja1JldHVyblZhbHVlT25jZSIsInJlc3VsdHMiLCJtYXAiLCJhdXRoZW50aWNhdGlvblRlc3RzIiwic2NlbmFyaW8iLCJ0ZXN0IiwiZWRnZUNhc2VzIiwiZWRnZUNhc2UiLCJ2ZXJ5TG9uZ1Bhc3N3b3JkIiwicmVwZWF0IiwidmVyeUxvbmdIYXNoIiwiYXR0YWNrUGF0dGVybnMiLCJwYXR0ZXJuIl0sIm1hcHBpbmdzIjoiOzs7O3lCQUFvQztvQ0FJN0I7MkJBRXlCO0FBRWhDQSxTQUFTLHNCQUFzQjtJQUM3QixJQUFJQztJQUNKLElBQUlDO0lBRUpDLFdBQVc7UUFDVCxNQUFNQyxxQkFBcUI7WUFDekJDLE1BQU1DLEtBQUtDLEVBQUU7WUFDYkMsU0FBU0YsS0FBS0MsRUFBRTtRQUNsQjtRQUVBLE1BQU1FLFNBQXdCLE1BQU1DLGFBQUksQ0FBQ0MsbUJBQW1CLENBQUM7WUFDM0RDLFdBQVc7Z0JBQ1RDLHNDQUFrQjtnQkFDbEI7b0JBQ0VDLFNBQVNDLDBCQUFlO29CQUN4QkMsVUFBVVo7Z0JBQ1o7YUFDRDtRQUNILEdBQUdhLE9BQU87UUFFVmhCLFVBQVVRLE9BQU9TLEdBQUcsQ0FBcUJMLHNDQUFrQjtRQUMzRFgsaUJBQWlCTyxPQUFPUyxHQUFHLENBQUNILDBCQUFlO0lBQzdDO0lBRUFmLFNBQVMsV0FBVztRQUNsQm1CLEdBQUcsaURBQWlEO1lBQ2xELE1BQU1DLFNBQW1DO2dCQUN2Q0MsVUFBVTtnQkFDVmhCLE1BQU07WUFDUjtZQUVBSCxlQUFlTSxPQUFPLENBQUNjLGVBQWUsQ0FBQztZQUV2QyxNQUFNQyxTQUFTdEIsUUFBUXVCLE9BQU8sQ0FBQ0o7WUFFL0JLLE9BQU9GLFFBQVFHLElBQUksQ0FBQztZQUNwQkQsT0FBT3ZCLGVBQWVNLE9BQU8sRUFBRW1CLG9CQUFvQixDQUNqRFAsT0FBT0MsUUFBUSxFQUNmRCxPQUFPZixJQUFJO1FBRWY7UUFFQWMsR0FBRyx5REFBeUQ7WUFDMUQsTUFBTUMsU0FBbUM7Z0JBQ3ZDQyxVQUFVO2dCQUNWaEIsTUFBTTtZQUNSO1lB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