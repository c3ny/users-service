f2e12f2921ca37c4cf348f55aa43758f
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _testing = require("@nestjs/testing");
const _hashStringuseCase = require("./hashString.useCase");
const _constants = require("../../../constants");
describe('HashStringUseCase', ()=>{
    let useCase;
    let hashRepository;
    beforeEach(async ()=>{
        const mockHashRepository = {
            hash: jest.fn(),
            compare: jest.fn()
        };
        const module = await _testing.Test.createTestingModule({
            providers: [
                _hashStringuseCase.HashStringUseCase,
                {
                    provide: _constants.HASH_REPOSITORY,
                    useValue: mockHashRepository
                }
            ]
        }).compile();
        useCase = module.get(_hashStringuseCase.HashStringUseCase);
        hashRepository = module.get(_constants.HASH_REPOSITORY);
    });
    describe('execute', ()=>{
        it('should hash a password successfully', ()=>{
            const password = 'mySecretPassword123';
            const hashedPassword = 'salt:hashedPassword123';
            hashRepository.hash.mockReturnValue(hashedPassword);
            const result = useCase.execute(password);
            expect(result).toBe(hashedPassword);
            expect(hashRepository.hash).toHaveBeenCalledWith(password);
        });
        it('should handle empty password', ()=>{
            const password = '';
            const hashedPassword = 'salt:hashedEmptyString';
            hashRepository.hash.mockReturnValue(hashedPassword);
            const result = useCase.execute(password);
            expect(result).toBe(hashedPassword);
            expect(hashRepository.hash).toHaveBeenCalledWith(password);
        });
        it('should handle different password lengths', ()=>{
            const passwords = [
                'a',
                'short',
                'mediumLengthPassword123',
                'veryLongPasswordWithManyCharactersAndNumbers123456789'
            ];
            passwords.forEach((password, index)=>{
                const hashedPassword = `salt:hashed_${index}`;
                hashRepository.hash.mockReturnValue(hashedPassword);
                const result = useCase.execute(password);
                expect(result).toBe(hashedPassword);
                expect(hashRepository.hash).toHaveBeenCalledWith(password);
            });
        });
        it('should handle passwords with special characters', ()=>{
            const specialPasswords = [
                'password@123',
                'p@ssw0rd!',
                'mY$ecr3t#P@ssw0rd',
                'test!@#$%^&*()_+',
                'àáâãäåæçèéêë'
            ];
            specialPasswords.forEach((password, index)=>{
                const hashedPassword = `salt:special_hashed_${index}`;
                hashRepository.hash.mockReturnValue(hashedPassword);
                const result = useCase.execute(password);
                expect(result).toBe(hashedPassword);
                expect(hashRepository.hash).toHaveBeenCalledWith(password);
            });
        });
        it('should handle passwords with numbers only', ()=>{
            const numericPasswords = [
                '123456',
                '987654321',
                '0000000000',
                '1234567890'
            ];
            numericPasswords.forEach((password, index)=>{
                const hashedPassword = `salt:numeric_hashed_${index}`;
                hashRepository.hash.mockReturnValue(hashedPassword);
                const result = useCase.execute(password);
                expect(result).toBe(hashedPassword);
                expect(hashRepository.hash).toHaveBeenCalledWith(password);
            });
        });
        it('should handle passwords with spaces', ()=>{
            const passwordsWithSpaces = [
                'password with spaces',
                ' leading space',
                'trailing space ',
                '  multiple  spaces  '
            ];
            passwordsWithSpaces.forEach((password, index)=>{
                const hashedPassword = `salt:space_hashed_${index}`;
                hashRepository.hash.mockReturnValue(hashedPassword);
                const result = useCase.execute(password);
                expect(result).toBe(hashedPassword);
                expect(hashRepository.hash).toHaveBeenCalledWith(password);
            });
        });
        it('should handle Unicode characters', ()=>{
            const unicodePasswords = [
                'contraseña123',
                'пароль123',
                '密码123',
                'パスワード123',
                '🔐🔑🛡️'
            ];
            unicodePasswords.forEach((password, index)=>{
                const hashedPassword = `salt:unicode_hashed_${index}`;
                hashRepository.hash.mockReturnValue(hashedPassword);
                const result = useCase.execute(password);
                expect(result).toBe(hashedPassword);
                expect(hashRepository.hash).toHaveBeenCalledWith(password);
            });
        });
        it('should handle same password multiple times', ()=>{
            const password = 'samePassword123';
            const hashedPassword1 = 'salt1:hashed1';
            const hashedPassword2 = 'salt2:hashed2';
            hashRepository.hash.mockReturnValueOnce(hashedPassword1).mockReturnValueOnce(hashedPassword2);
            const result1 = useCase.execute(password);
            const result2 = useCase.execute(password);
            expect(result1).toBe(hashedPassword1);
            expect(result2).toBe(hashedPassword2);
            expect(hashRepository.hash).toHaveBeenCalledTimes(2);
            expect(hashRepository.hash).toHaveBeenNthCalledWith(1, password);
            expect(hashRepository.hash).toHaveBeenNthCalledWith(2, password);
        });
        it('should handle repository errors gracefully', ()=>{
            const password = 'testPassword';
            hashRepository.hash.mockImplementation(()=>{
                throw new Error('Hashing service unavailable');
            });
            expect(()=>useCase.execute(password)).toThrow('Hashing service unavailable');
            expect(hashRepository.hash).toHaveBeenCalledWith(password);
        });
        it('should handle very long passwords', ()=>{
            const veryLongPassword = 'a'.repeat(10000); // 10,000 characters
            const hashedPassword = 'salt:hashedVeryLongPassword';
            hashRepository.hash.mockReturnValue(hashedPassword);
            const result = useCase.execute(veryLongPassword);
            expect(result).toBe(hashedPassword);
            expect(hashRepository.hash).toHaveBeenCalledWith(veryLongPassword);
        });
        it('should handle common password patterns', ()=>{
            const commonPatterns = [
                '123456789',
                'password123',
                'qwerty123',
                'admin123',
                'user123',
                'test123'
            ];
            commonPatterns.forEach((password, index)=>{
                const hashedPassword = `salt:common_hashed_${index}`;
                hashRepository.hash.mockReturnValue(hashedPassword);
                const result = useCase.execute(password);
                expect(result).toBe(hashedPassword);
                expect(hashRepository.hash).toHaveBeenCalledWith(password);
            });
        });
        it('should handle concurrent hashing requests', ()=>{
            const passwords = [
                'password1',
                'password2',
                'password3',
                'password4',
                'password5'
            ];
            const hashedPasswords = passwords.map((_, index)=>`salt${index}:hashed_${index}`);
            hashRepository.hash.mockReturnValueOnce(hashedPasswords[0]).mockReturnValueOnce(hashedPasswords[1]).mockReturnValueOnce(hashedPasswords[2]).mockReturnValueOnce(hashedPasswords[3]).mockReturnValueOnce(hashedPasswords[4]);
            const results = passwords.map((password)=>useCase.execute(password));
            results.forEach((result, index)=>{
                expect(result).toBe(hashedPasswords[index]);
            });
            expect(hashRepository.hash).toHaveBeenCalledTimes(5);
            passwords.forEach((password, index)=>{
                expect(hashRepository.hash).toHaveBeenNthCalledWith(index + 1, password);
            });
        });
        it('should handle edge case characters', ()=>{
            const edgeCasePasswords = [
                '\n',
                '\t',
                '\r',
                '\0',
                '\\',
                '"',
                "'"
            ];
            edgeCasePasswords.forEach((password, index)=>{
                const hashedPassword = `salt:edge_hashed_${index}`;
                hashRepository.hash.mockReturnValue(hashedPassword);
                const result = useCase.execute(password);
                expect(result).toBe(hashedPassword);
                expect(hashRepository.hash).toHaveBeenCalledWith(password);
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy95c3JhZWxtb3Jlbm8vRG9jdW1lbnRzL2NvZGVzL2ZhdGVjL3Nhbmd1ZS1zb2xpZGFyaW8vdXNlcnMtc2VydmljZS9zcmMvbW9kdWxlcy9IYXNoL2FwcGxpY2F0aW9uL3BvcnRzL2luL2hhc2hTdHJpbmcudXNlQ2FzZS5zcGVjLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRlc3QsIFRlc3RpbmdNb2R1bGUgfSBmcm9tICdAbmVzdGpzL3Rlc3RpbmcnO1xuaW1wb3J0IHsgSGFzaFN0cmluZ1VzZUNhc2UgfSBmcm9tICcuL2hhc2hTdHJpbmcudXNlQ2FzZSc7XG5pbXBvcnQgeyBIYXNoUmVwb3NpdG9yeVBvcnQgfSBmcm9tICcuLi9vdXQvaGFzaC1yZXBvc2l0b3J5LnBvcnQnO1xuaW1wb3J0IHsgSEFTSF9SRVBPU0lUT1JZIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzJztcblxuZGVzY3JpYmUoJ0hhc2hTdHJpbmdVc2VDYXNlJywgKCkgPT4ge1xuICBsZXQgdXNlQ2FzZTogSGFzaFN0cmluZ1VzZUNhc2U7XG4gIGxldCBoYXNoUmVwb3NpdG9yeTogamVzdC5Nb2NrZWQ8SGFzaFJlcG9zaXRvcnlQb3J0PjtcblxuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2NrSGFzaFJlcG9zaXRvcnkgPSB7XG4gICAgICBoYXNoOiBqZXN0LmZuKCksXG4gICAgICBjb21wYXJlOiBqZXN0LmZuKCksXG4gICAgfTtcblxuICAgIGNvbnN0IG1vZHVsZTogVGVzdGluZ01vZHVsZSA9IGF3YWl0IFRlc3QuY3JlYXRlVGVzdGluZ01vZHVsZSh7XG4gICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgSGFzaFN0cmluZ1VzZUNhc2UsXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBIQVNIX1JFUE9TSVRPUlksXG4gICAgICAgICAgdXNlVmFsdWU6IG1vY2tIYXNoUmVwb3NpdG9yeSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSkuY29tcGlsZSgpO1xuXG4gICAgdXNlQ2FzZSA9IG1vZHVsZS5nZXQ8SGFzaFN0cmluZ1VzZUNhc2U+KEhhc2hTdHJpbmdVc2VDYXNlKTtcbiAgICBoYXNoUmVwb3NpdG9yeSA9IG1vZHVsZS5nZXQoSEFTSF9SRVBPU0lUT1JZKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2V4ZWN1dGUnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYXNoIGEgcGFzc3dvcmQgc3VjY2Vzc2Z1bGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSAnbXlTZWNyZXRQYXNzd29yZDEyMyc7XG4gICAgICBjb25zdCBoYXNoZWRQYXNzd29yZDogYCR7c3RyaW5nfToke3N0cmluZ31gID0gJ3NhbHQ6aGFzaGVkUGFzc3dvcmQxMjMnO1xuXG4gICAgICBoYXNoUmVwb3NpdG9yeS5oYXNoLm1vY2tSZXR1cm5WYWx1ZShoYXNoZWRQYXNzd29yZCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZUNhc2UuZXhlY3V0ZShwYXNzd29yZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoaGFzaGVkUGFzc3dvcmQpO1xuICAgICAgZXhwZWN0KGhhc2hSZXBvc2l0b3J5Lmhhc2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHBhc3N3b3JkKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IHBhc3N3b3JkJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSAnJztcbiAgICAgIGNvbnN0IGhhc2hlZFBhc3N3b3JkOiBgJHtzdHJpbmd9OiR7c3RyaW5nfWAgPSAnc2FsdDpoYXNoZWRFbXB0eVN0cmluZyc7XG5cbiAgICAgIGhhc2hSZXBvc2l0b3J5Lmhhc2gubW9ja1JldHVyblZhbHVlKGhhc2hlZFBhc3N3b3JkKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gdXNlQ2FzZS5leGVjdXRlKHBhc3N3b3JkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShoYXNoZWRQYXNzd29yZCk7XG4gICAgICBleHBlY3QoaGFzaFJlcG9zaXRvcnkuaGFzaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgocGFzc3dvcmQpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGlmZmVyZW50IHBhc3N3b3JkIGxlbmd0aHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXNzd29yZHMgPSBbXG4gICAgICAgICdhJywgLy8gU2luZ2xlIGNoYXJhY3RlclxuICAgICAgICAnc2hvcnQnLCAvLyBTaG9ydCBwYXNzd29yZFxuICAgICAgICAnbWVkaXVtTGVuZ3RoUGFzc3dvcmQxMjMnLCAvLyBNZWRpdW0gcGFzc3dvcmRcbiAgICAgICAgJ3ZlcnlMb25nUGFzc3dvcmRXaXRoTWFueUNoYXJhY3RlcnNBbmROdW1iZXJzMTIzNDU2Nzg5JywgLy8gTG9uZyBwYXNzd29yZFxuICAgICAgXTtcblxuICAgICAgcGFzc3dvcmRzLmZvckVhY2goKHBhc3N3b3JkLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBoYXNoZWRQYXNzd29yZDogYCR7c3RyaW5nfToke3N0cmluZ31gID0gYHNhbHQ6aGFzaGVkXyR7aW5kZXh9YDtcbiAgICAgICAgaGFzaFJlcG9zaXRvcnkuaGFzaC5tb2NrUmV0dXJuVmFsdWUoaGFzaGVkUGFzc3dvcmQpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZUNhc2UuZXhlY3V0ZShwYXNzd29yZCk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShoYXNoZWRQYXNzd29yZCk7XG4gICAgICAgIGV4cGVjdChoYXNoUmVwb3NpdG9yeS5oYXNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChwYXNzd29yZCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHBhc3N3b3JkcyB3aXRoIHNwZWNpYWwgY2hhcmFjdGVycycsICgpID0+IHtcbiAgICAgIGNvbnN0IHNwZWNpYWxQYXNzd29yZHMgPSBbXG4gICAgICAgICdwYXNzd29yZEAxMjMnLFxuICAgICAgICAncEBzc3cwcmQhJyxcbiAgICAgICAgJ21ZJGVjcjN0I1BAc3N3MHJkJyxcbiAgICAgICAgJ3Rlc3QhQCMkJV4mKigpXysnLFxuICAgICAgICAnw6DDocOiw6PDpMOlw6bDp8Oow6nDqsOrJyxcbiAgICAgIF07XG5cbiAgICAgIHNwZWNpYWxQYXNzd29yZHMuZm9yRWFjaCgocGFzc3dvcmQsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc2hlZFBhc3N3b3JkOiBgJHtzdHJpbmd9OiR7c3RyaW5nfWAgPSBgc2FsdDpzcGVjaWFsX2hhc2hlZF8ke2luZGV4fWA7XG4gICAgICAgIGhhc2hSZXBvc2l0b3J5Lmhhc2gubW9ja1JldHVyblZhbHVlKGhhc2hlZFBhc3N3b3JkKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB1c2VDYXNlLmV4ZWN1dGUocGFzc3dvcmQpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoaGFzaGVkUGFzc3dvcmQpO1xuICAgICAgICBleHBlY3QoaGFzaFJlcG9zaXRvcnkuaGFzaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgocGFzc3dvcmQpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBwYXNzd29yZHMgd2l0aCBudW1iZXJzIG9ubHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBudW1lcmljUGFzc3dvcmRzID0gW1xuICAgICAgICAnMTIzNDU2JyxcbiAgICAgICAgJzk4NzY1NDMyMScsXG4gICAgICAgICcwMDAwMDAwMDAwJyxcbiAgICAgICAgJzEyMzQ1Njc4OTAnLFxuICAgICAgXTtcblxuICAgICAgbnVtZXJpY1Bhc3N3b3Jkcy5mb3JFYWNoKChwYXNzd29yZCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgaGFzaGVkUGFzc3dvcmQ6IGAke3N0cmluZ306JHtzdHJpbmd9YCA9IGBzYWx0Om51bWVyaWNfaGFzaGVkXyR7aW5kZXh9YDtcbiAgICAgICAgaGFzaFJlcG9zaXRvcnkuaGFzaC5tb2NrUmV0dXJuVmFsdWUoaGFzaGVkUGFzc3dvcmQpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZUNhc2UuZXhlY3V0ZShwYXNzd29yZCk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShoYXNoZWRQYXNzd29yZCk7XG4gICAgICAgIGV4cGVjdChoYXNoUmVwb3NpdG9yeS5oYXNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChwYXNzd29yZCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHBhc3N3b3JkcyB3aXRoIHNwYWNlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhc3N3b3Jkc1dpdGhTcGFjZXMgPSBbXG4gICAgICAgICdwYXNzd29yZCB3aXRoIHNwYWNlcycsXG4gICAgICAgICcgbGVhZGluZyBzcGFjZScsXG4gICAgICAgICd0cmFpbGluZyBzcGFjZSAnLFxuICAgICAgICAnICBtdWx0aXBsZSAgc3BhY2VzICAnLFxuICAgICAgXTtcblxuICAgICAgcGFzc3dvcmRzV2l0aFNwYWNlcy5mb3JFYWNoKChwYXNzd29yZCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgaGFzaGVkUGFzc3dvcmQ6IGAke3N0cmluZ306JHtzdHJpbmd9YCA9IGBzYWx0OnNwYWNlX2hhc2hlZF8ke2luZGV4fWA7XG4gICAgICAgIGhhc2hSZXBvc2l0b3J5Lmhhc2gubW9ja1JldHVyblZhbHVlKGhhc2hlZFBhc3N3b3JkKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB1c2VDYXNlLmV4ZWN1dGUocGFzc3dvcmQpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoaGFzaGVkUGFzc3dvcmQpO1xuICAgICAgICBleHBlY3QoaGFzaFJlcG9zaXRvcnkuaGFzaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgocGFzc3dvcmQpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBVbmljb2RlIGNoYXJhY3RlcnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB1bmljb2RlUGFzc3dvcmRzID0gW1xuICAgICAgICAnY29udHJhc2XDsWExMjMnLCAvLyBTcGFuaXNoXG4gICAgICAgICfQv9Cw0YDQvtC70YwxMjMnLCAvLyBSdXNzaWFuXG4gICAgICAgICflr4bnoIExMjMnLCAvLyBDaGluZXNlXG4gICAgICAgICfjg5Hjgrnjg6/jg7zjg4kxMjMnLCAvLyBKYXBhbmVzZVxuICAgICAgICAn8J+UkPCflJHwn5uh77iPJywgLy8gRW1vamlzXG4gICAgICBdO1xuXG4gICAgICB1bmljb2RlUGFzc3dvcmRzLmZvckVhY2goKHBhc3N3b3JkLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBoYXNoZWRQYXNzd29yZDogYCR7c3RyaW5nfToke3N0cmluZ31gID0gYHNhbHQ6dW5pY29kZV9oYXNoZWRfJHtpbmRleH1gO1xuICAgICAgICBoYXNoUmVwb3NpdG9yeS5oYXNoLm1vY2tSZXR1cm5WYWx1ZShoYXNoZWRQYXNzd29yZCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdXNlQ2FzZS5leGVjdXRlKHBhc3N3b3JkKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKGhhc2hlZFBhc3N3b3JkKTtcbiAgICAgICAgZXhwZWN0KGhhc2hSZXBvc2l0b3J5Lmhhc2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHBhc3N3b3JkKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2FtZSBwYXNzd29yZCBtdWx0aXBsZSB0aW1lcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gJ3NhbWVQYXNzd29yZDEyMyc7XG4gICAgICBjb25zdCBoYXNoZWRQYXNzd29yZDE6IGAke3N0cmluZ306JHtzdHJpbmd9YCA9ICdzYWx0MTpoYXNoZWQxJztcbiAgICAgIGNvbnN0IGhhc2hlZFBhc3N3b3JkMjogYCR7c3RyaW5nfToke3N0cmluZ31gID0gJ3NhbHQyOmhhc2hlZDInO1xuXG4gICAgICBoYXNoUmVwb3NpdG9yeS5oYXNoXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKGhhc2hlZFBhc3N3b3JkMSlcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoaGFzaGVkUGFzc3dvcmQyKTtcblxuICAgICAgY29uc3QgcmVzdWx0MSA9IHVzZUNhc2UuZXhlY3V0ZShwYXNzd29yZCk7XG4gICAgICBjb25zdCByZXN1bHQyID0gdXNlQ2FzZS5leGVjdXRlKHBhc3N3b3JkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdDEpLnRvQmUoaGFzaGVkUGFzc3dvcmQxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQyKS50b0JlKGhhc2hlZFBhc3N3b3JkMik7XG4gICAgICBleHBlY3QoaGFzaFJlcG9zaXRvcnkuaGFzaCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgZXhwZWN0KGhhc2hSZXBvc2l0b3J5Lmhhc2gpLnRvSGF2ZUJlZW5OdGhDYWxsZWRXaXRoKDEsIHBhc3N3b3JkKTtcbiAgICAgIGV4cGVjdChoYXNoUmVwb3NpdG9yeS5oYXNoKS50b0hhdmVCZWVuTnRoQ2FsbGVkV2l0aCgyLCBwYXNzd29yZCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByZXBvc2l0b3J5IGVycm9ycyBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSAndGVzdFBhc3N3b3JkJztcbiAgICAgIGhhc2hSZXBvc2l0b3J5Lmhhc2gubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoaW5nIHNlcnZpY2UgdW5hdmFpbGFibGUnKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoKCkgPT4gdXNlQ2FzZS5leGVjdXRlKHBhc3N3b3JkKSkudG9UaHJvdyhcbiAgICAgICAgJ0hhc2hpbmcgc2VydmljZSB1bmF2YWlsYWJsZScsXG4gICAgICApO1xuICAgICAgZXhwZWN0KGhhc2hSZXBvc2l0b3J5Lmhhc2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHBhc3N3b3JkKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHZlcnkgbG9uZyBwYXNzd29yZHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB2ZXJ5TG9uZ1Bhc3N3b3JkID0gJ2EnLnJlcGVhdCgxMDAwMCk7IC8vIDEwLDAwMCBjaGFyYWN0ZXJzXG4gICAgICBjb25zdCBoYXNoZWRQYXNzd29yZDogYCR7c3RyaW5nfToke3N0cmluZ31gID1cbiAgICAgICAgJ3NhbHQ6aGFzaGVkVmVyeUxvbmdQYXNzd29yZCc7XG5cbiAgICAgIGhhc2hSZXBvc2l0b3J5Lmhhc2gubW9ja1JldHVyblZhbHVlKGhhc2hlZFBhc3N3b3JkKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gdXNlQ2FzZS5leGVjdXRlKHZlcnlMb25nUGFzc3dvcmQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGhhc2hlZFBhc3N3b3JkKTtcbiAgICAgIGV4cGVjdChoYXNoUmVwb3NpdG9yeS5oYXNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh2ZXJ5TG9uZ1Bhc3N3b3JkKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbW1vbiBwYXNzd29yZCBwYXR0ZXJucycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbW1vblBhdHRlcm5zID0gW1xuICAgICAgICAnMTIzNDU2Nzg5JyxcbiAgICAgICAgJ3Bhc3N3b3JkMTIzJyxcbiAgICAgICAgJ3F3ZXJ0eTEyMycsXG4gICAgICAgICdhZG1pbjEyMycsXG4gICAgICAgICd1c2VyMTIzJyxcbiAgICAgICAgJ3Rlc3QxMjMnLFxuICAgICAgXTtcblxuICAgICAgY29tbW9uUGF0dGVybnMuZm9yRWFjaCgocGFzc3dvcmQsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc2hlZFBhc3N3b3JkOiBgJHtzdHJpbmd9OiR7c3RyaW5nfWAgPSBgc2FsdDpjb21tb25faGFzaGVkXyR7aW5kZXh9YDtcbiAgICAgICAgaGFzaFJlcG9zaXRvcnkuaGFzaC5tb2NrUmV0dXJuVmFsdWUoaGFzaGVkUGFzc3dvcmQpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZUNhc2UuZXhlY3V0ZShwYXNzd29yZCk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShoYXNoZWRQYXNzd29yZCk7XG4gICAgICAgIGV4cGVjdChoYXNoUmVwb3NpdG9yeS5oYXNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChwYXNzd29yZCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgaGFzaGluZyByZXF1ZXN0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhc3N3b3JkcyA9IFtcbiAgICAgICAgJ3Bhc3N3b3JkMScsXG4gICAgICAgICdwYXNzd29yZDInLFxuICAgICAgICAncGFzc3dvcmQzJyxcbiAgICAgICAgJ3Bhc3N3b3JkNCcsXG4gICAgICAgICdwYXNzd29yZDUnLFxuICAgICAgXTtcbiAgICAgIGNvbnN0IGhhc2hlZFBhc3N3b3JkczogYCR7c3RyaW5nfToke3N0cmluZ31gW10gPSBwYXNzd29yZHMubWFwKFxuICAgICAgICAoXywgaW5kZXgpOiBgJHtzdHJpbmd9OiR7c3RyaW5nfWAgPT4gYHNhbHQke2luZGV4fTpoYXNoZWRfJHtpbmRleH1gLFxuICAgICAgKTtcblxuICAgICAgaGFzaFJlcG9zaXRvcnkuaGFzaFxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZShoYXNoZWRQYXNzd29yZHNbMF0pXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKGhhc2hlZFBhc3N3b3Jkc1sxXSlcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoaGFzaGVkUGFzc3dvcmRzWzJdKVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZShoYXNoZWRQYXNzd29yZHNbM10pXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKGhhc2hlZFBhc3N3b3Jkc1s0XSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBwYXNzd29yZHMubWFwKChwYXNzd29yZCkgPT4gdXNlQ2FzZS5leGVjdXRlKHBhc3N3b3JkKSk7XG5cbiAgICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0LCBpbmRleCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKGhhc2hlZFBhc3N3b3Jkc1tpbmRleF0pO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChoYXNoUmVwb3NpdG9yeS5oYXNoKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoNSk7XG4gICAgICBwYXNzd29yZHMuZm9yRWFjaCgocGFzc3dvcmQsIGluZGV4KSA9PiB7XG4gICAgICAgIGV4cGVjdChoYXNoUmVwb3NpdG9yeS5oYXNoKS50b0hhdmVCZWVuTnRoQ2FsbGVkV2l0aChcbiAgICAgICAgICBpbmRleCArIDEsXG4gICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVkZ2UgY2FzZSBjaGFyYWN0ZXJzJywgKCkgPT4ge1xuICAgICAgY29uc3QgZWRnZUNhc2VQYXNzd29yZHMgPSBbXG4gICAgICAgICdcXG4nLCAvLyBOZXdsaW5lXG4gICAgICAgICdcXHQnLCAvLyBUYWJcbiAgICAgICAgJ1xccicsIC8vIENhcnJpYWdlIHJldHVyblxuICAgICAgICAnXFwwJywgLy8gTnVsbCBjaGFyYWN0ZXJcbiAgICAgICAgJ1xcXFwnLCAvLyBCYWNrc2xhc2hcbiAgICAgICAgJ1wiJywgLy8gUXVvdGVcbiAgICAgICAgXCInXCIsIC8vIFNpbmdsZSBxdW90ZVxuICAgICAgXTtcblxuICAgICAgZWRnZUNhc2VQYXNzd29yZHMuZm9yRWFjaCgocGFzc3dvcmQsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc2hlZFBhc3N3b3JkOiBgJHtzdHJpbmd9OiR7c3RyaW5nfWAgPSBgc2FsdDplZGdlX2hhc2hlZF8ke2luZGV4fWA7XG4gICAgICAgIGhhc2hSZXBvc2l0b3J5Lmhhc2gubW9ja1JldHVyblZhbHVlKGhhc2hlZFBhc3N3b3JkKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB1c2VDYXNlLmV4ZWN1dGUocGFzc3dvcmQpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoaGFzaGVkUGFzc3dvcmQpO1xuICAgICAgICBleHBlY3QoaGFzaFJlcG9zaXRvcnkuaGFzaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgocGFzc3dvcmQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJ1c2VDYXNlIiwiaGFzaFJlcG9zaXRvcnkiLCJiZWZvcmVFYWNoIiwibW9ja0hhc2hSZXBvc2l0b3J5IiwiaGFzaCIsImplc3QiLCJmbiIsImNvbXBhcmUiLCJtb2R1bGUiLCJUZXN0IiwiY3JlYXRlVGVzdGluZ01vZHVsZSIsInByb3ZpZGVycyIsIkhhc2hTdHJpbmdVc2VDYXNlIiwicHJvdmlkZSIsIkhBU0hfUkVQT1NJVE9SWSIsInVzZVZhbHVlIiwiY29tcGlsZSIsImdldCIsIml0IiwicGFzc3dvcmQiLCJoYXNoZWRQYXNzd29yZCIsIm1vY2tSZXR1cm5WYWx1ZSIsInJlc3VsdCIsImV4ZWN1dGUiLCJleHBlY3QiLCJ0b0JlIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJwYXNzd29yZHMiLCJmb3JFYWNoIiwiaW5kZXgiLCJzcGVjaWFsUGFzc3dvcmRzIiwibnVtZXJpY1Bhc3N3b3JkcyIsInBhc3N3b3Jkc1dpdGhTcGFjZXMiLCJ1bmljb2RlUGFzc3dvcmRzIiwiaGFzaGVkUGFzc3dvcmQxIiwiaGFzaGVkUGFzc3dvcmQyIiwibW9ja1JldHVyblZhbHVlT25jZSIsInJlc3VsdDEiLCJyZXN1bHQyIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwidG9IYXZlQmVlbk50aENhbGxlZFdpdGgiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJFcnJvciIsInRvVGhyb3ciLCJ2ZXJ5TG9uZ1Bhc3N3b3JkIiwicmVwZWF0IiwiY29tbW9uUGF0dGVybnMiLCJoYXNoZWRQYXNzd29yZHMiLCJtYXAiLCJfIiwicmVzdWx0cyIsImVkZ2VDYXNlUGFzc3dvcmRzIl0sIm1hcHBpbmdzIjoiOzs7O3lCQUFvQzttQ0FDRjsyQkFFRjtBQUVoQ0EsU0FBUyxxQkFBcUI7SUFDNUIsSUFBSUM7SUFDSixJQUFJQztJQUVKQyxXQUFXO1FBQ1QsTUFBTUMscUJBQXFCO1lBQ3pCQyxNQUFNQyxLQUFLQyxFQUFFO1lBQ2JDLFNBQVNGLEtBQUtDLEVBQUU7UUFDbEI7UUFFQSxNQUFNRSxTQUF3QixNQUFNQyxhQUFJLENBQUNDLG1CQUFtQixDQUFDO1lBQzNEQyxXQUFXO2dCQUNUQyxvQ0FBaUI7Z0JBQ2pCO29CQUNFQyxTQUFTQywwQkFBZTtvQkFDeEJDLFVBQVVaO2dCQUNaO2FBQ0Q7UUFDSCxHQUFHYSxPQUFPO1FBRVZoQixVQUFVUSxPQUFPUyxHQUFHLENBQW9CTCxvQ0FBaUI7UUFDekRYLGlCQUFpQk8sT0FBT1MsR0FBRyxDQUFDSCwwQkFBZTtJQUM3QztJQUVBZixTQUFTLFdBQVc7UUFDbEJtQixHQUFHLHVDQUF1QztZQUN4QyxNQUFNQyxXQUFXO1lBQ2pCLE1BQU1DLGlCQUF3QztZQUU5Q25CLGVBQWVHLElBQUksQ0FBQ2lCLGVBQWUsQ0FBQ0Q7WUFFcEMsTUFBTUUsU0FBU3RCLFFBQVF1QixPQUFPLENBQUNKO1lBRS9CSyxPQUFPRixRQUFRRyxJQUFJLENBQUNMO1lBQ3BCSSxPQUFPdkIsZUFBZUcsSUFBSSxFQUFFc0Isb0JBQW9CLENBQUNQO1FBQ25EO1FBRUFELEdBQUcsZ0NBQWdDO1lBQ2pDLE1BQU1DLFdBQVc7WUFDakIsTUFBTUMsaUJBQXdDO1lBRTlDbkIsZUFBZUcsSUFBSSxDQUFDaUIsZUFBZSxDQUFDRDtZQUVwQyxNQUFNRSxTQUFTdEIsUUFBUXVCLE9BQU8sQ0FBQ0o7WUFFL0JLLE9BQU9GLFFBQVFHLElBQUksQ0FBQ0w7WUFDcEJJLE9BQU92QixlQUFlRyxJQUFJLEVBQUVzQixvQkFBb0IsQ0FBQ1A7UUFDbkQ7UUFFQUQsR0FBRyw0Q0FBNEM7WUFDN0MsTUFBTVMsWUFBWTtnQkFDaEI7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDRDtZQUVEQSxVQUFVQyxPQUFPLENBQUMsQ0FBQ1QsVUFBVVU7Z0JBQzNCLE1BQU1ULGlCQUF3QyxDQUFDLFlBQVksRUFBRVMsT0FBTztnQkFDcEU1QixlQUFlRyxJQUFJLENBQUNpQixlQUFlLENBQUNEO2dCQUVwQyxNQUFNRSxTQUFTdEIsUUFBUXVCLE9BQU8sQ0FBQ0o7Z0JBRS9CSyxPQUFPRixRQUFRRyxJQUFJLENBQUNMO2dCQUNwQkksT0FBT3ZCLGVBQWVHLElBQUksRUFBRXNCLG9CQUFvQixDQUFDUDtZQUNuRDtRQUNGO1FBRUFELEdBQUcsbURBQW1EO1lBQ3BELE1BQU1ZLG1CQUFtQjtnQkFDdkI7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDRDtZQUVEQSxpQkFBaUJGLE9BQU8sQ0FBQyxDQUFDVCxVQUFVVTtnQkFDbEMsTUFBTVQsaUJBQXdDLENBQUMsb0JBQW9CLEVBQUVTLE9BQU87Z0JBQzVFNUIsZUFBZUcsSUFBSSxDQUFDaUIsZUFBZSxDQUFDRDtnQkFFcEMsTUFBTUUsU0FBU3RCLFFBQVF1QixPQUFPLENBQUNKO2dCQUUvQkssT0FBT0YsUUFBUUcsSUFBSSxDQUFDTDtnQkFDcEJJLE9BQU92QixlQUFlRyxJQUFJLEVBQUVzQixvQkFBb0IsQ0FBQ1A7WUFDbkQ7UUFDRjtRQUVBRCxHQUFHLDZDQUE2QztZQUM5QyxNQUFNYSxtQkFBbUI7Z0JBQ3ZCO2dCQUNBO2dCQUNBO2dCQUNBO2FBQ0Q7WUFFREEsaUJBQWlCSCxPQUFPLENBQUMsQ0FBQ1QsVUFBVVU7Z0JBQ2xDLE1BQU1ULGlCQUF3QyxDQUFDLG9CQUFvQixFQUFFUyxPQUFPO2dCQUM1RTVCLGVBQWVHLElBQUksQ0FBQ2lCLGVBQWUsQ0FBQ0Q7Z0JBRXBDLE1BQU1FLFNBQVN0QixRQUFRdUIsT0FBTyxDQUFDSjtnQkFFL0JLLE9BQU9GLFFBQVFHLElBQUksQ0FBQ0w7Z0JBQ3BCSSxPQUFPdkIsZUFBZUcsSUFBSSxFQUFFc0Isb0JBQW9CLENBQUNQO1lBQ25EO1FBQ0Y7UUFFQUQsR0FBRyx1Q0FBdUM7WUFDeEMsTUFBTWMsc0JBQXNCO2dCQUMxQjtnQkFDQTtnQkFDQTtnQkFDQTthQUNEO1lBRURBLG9CQUFvQkosT0FBTyxDQUFDLENBQUNULFVBQVVVO2dCQUNyQyxNQUFNVCxpQkFBd0MsQ0FBQyxrQkFBa0IsRUFBRVMsT0FBTztnQkFDMUU1QixlQUFlRyxJQUFJLENBQUNpQixlQUFlLENBQUNEO2dCQUVwQyxNQUFNRSxTQUFTdEIsUUFBUXVCLE9BQU8sQ0FBQ0o7Z0JBRS9CSyxPQUFPRixRQUFRRyxJQUFJLENBQUNMO2dCQUNwQkksT0FBT3ZCLGVBQWVHLElBQUksRUFBRXNCLG9CQUFvQixDQUFDUDtZQUNuRDtRQUNGO1FBRUFELEdBQUcsb0NBQW9DO1lBQ3JDLE1BQU1lLG1CQUFtQjtnQkFDdkI7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDRDtZQUVEQSxpQkFBaUJMLE9BQU8sQ0FBQyxDQUFDVCxVQUFVVTtnQkFDbEMsTUFBTVQsaUJBQXdDLENBQUMsb0JBQW9CLEVBQUVTLE9BQU87Z0JBQzVFNUIsZUFBZUcsSUFBSSxDQUFDaUIsZUFBZSxDQUFDRDtnQkFFcEMsTUFBTUUsU0FBU3RCLFFBQVF1QixPQUFPLENBQUNKO2dCQUUvQkssT0FBT0YsUUFBUUcsSUFBSSxDQUFDTDtnQkFDcEJJLE9BQU92QixlQUFlRyxJQUFJLEVBQUVzQixvQkFBb0IsQ0FBQ1A7WUFDbkQ7UUFDRjtRQUVBRCxHQUFHLDhDQUE4QztZQUMvQyxNQUFNQyxXQUFXO1lBQ2pCLE1BQU1lLGtCQUF5QztZQUMvQyxNQUFNQyxrQkFBeUM7WUFFL0NsQyxlQUFlRyxJQUFJLENBQ2hCZ0MsbUJBQW1CLENBQUNGLGlCQUNwQkUsbUJBQW1CLENBQUNEO1lBRXZCLE1BQU1FLFVBQVVyQyxRQUFRdUIsT0FBTyxDQUFDSjtZQUNoQyxNQUFNbUIsVUFBVXRDLFFBQVF1QixPQUFPLENBQUNKO1lBRWhDSyxPQUFPYSxTQUFTWixJQUFJLENBQUNTO1lBQ3JCVixPQUFPYyxTQUFTYixJQUFJLENBQUNVO1lBQ3JCWCxPQUFPdkIsZUFBZUcsSUFBSSxFQUFFbUMscUJBQXFCLENBQUM7WUFDbERmLE9BQU92QixlQUFlRyxJQUFJLEVBQUVvQyx1QkFBdUIsQ0FBQyxHQUFHckI7WUFDdkRLLE9BQU92QixlQUFlRyxJQUFJLEVBQUVvQyx1QkFBdUIsQ0FBQyxHQUFHckI7UUFDekQ7UUFFQUQsR0FBRyw4Q0FBOEM7WUFDL0MsTUFBTUMsV0FBVztZQUNqQmxCLGVBQWVHLElBQUksQ0FBQ3FDLGtCQUFrQixDQUFDO2dCQUNyQyxNQUFNLElBQUlDLE1BQU07WUFDbEI7WUFFQWxCLE9BQU8sSUFBTXhCLFFBQVF1QixPQUFPLENBQUNKLFdBQVd3QixPQUFPLENBQzdDO1lBRUZuQixPQUFPdkIsZUFBZUcsSUFBSSxFQUFFc0Isb0JBQW9CLENBQUNQO1FBQ25EO1FBRUFELEdBQUcscUNBQXFDO1lBQ3RDLE1BQU0wQixtQkFBbUIsSUFBSUMsTUFBTSxDQUFDLFFBQVEsb0JBQW9CO1lBQ2hFLE1BQU16QixpQkFDSjtZQUVGbkIsZUFBZUcsSUFBSSxDQUFDaUIsZUFBZSxDQUFDRDtZQUVwQyxNQUFNRSxTQUFTdEIsUUFBUXVCLE9BQU8sQ0FBQ3FCO1lBRS9CcEIsT0FBT0YsUUFBUUcsSUFBSSxDQUFDTDtZQUNwQkksT0FBT3ZCLGVBQWVHLElBQUksRUFBRXNCLG9CQUFvQixDQUFDa0I7UUFDbkQ7UUFFQTFCLEdBQUcsMENBQTBDO1lBQzNDLE1BQU00QixpQkFBaUI7Z0JBQ3JCO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2FBQ0Q7WUFFREEsZUFBZWxCLE9BQU8sQ0FBQyxDQUFDVCxVQUFVVTtnQkFDaEMsTUFBTVQsaUJBQXdDLENBQUMsbUJBQW1CLEVBQUVTLE9BQU87Z0JBQzNFNUIsZUFBZUcsSUFBSSxDQUFDaUIsZUFBZSxDQUFDRDtnQkFFcEMsTUFBTUUsU0FBU3RCLFFBQVF1QixPQUFPLENBQUNKO2dCQUUvQkssT0FBT0YsUUFBUUcsSUFBSSxDQUFDTDtnQkFDcEJJLE9BQU92QixlQUFlRyxJQUFJLEVBQUVzQixvQkFBb0IsQ0FBQ1A7WUFDbkQ7UUFDRjtRQUVBRCxHQUFHLDZDQUE2QztZQUM5QyxNQUFNUyxZQUFZO2dCQUNoQjtnQkFDQTtnQkFDQTtnQkFDQTtnQkFDQTthQUNEO1lBQ0QsTUFBTW9CLGtCQUEyQ3BCLFVBQVVxQixHQUFHLENBQzVELENBQUNDLEdBQUdwQixRQUFpQyxDQUFDLElBQUksRUFBRUEsTUFBTSxRQUFRLEVBQUVBLE9BQU87WUFHckU1QixlQUFlRyxJQUFJLENBQ2hCZ0MsbUJBQW1CLENBQUNXLGVBQWUsQ0FBQyxFQUFFLEVBQ3RDWCxtQkFBbUIsQ0FBQ1csZUFBZSxDQUFDLEVBQUUsRUFDdENYLG1CQUFtQixDQUFDVyxlQUFlLENBQUMsRUFBRSxFQUN0Q1gsbUJBQW1CLENBQUNXLGVBQWUsQ0FBQyxFQUFFLEVBQ3RDWCxtQkFBbUIsQ0FBQ1csZUFBZSxDQUFDLEVBQUU7WUFFekMsTUFBTUcsVUFBVXZCLFVBQVVxQixHQUFHLENBQUMsQ0FBQzdCLFdBQWFuQixRQUFRdUIsT0FBTyxDQUFDSjtZQUU1RCtCLFFBQVF0QixPQUFPLENBQUMsQ0FBQ04sUUFBUU87Z0JBQ3ZCTCxPQUFPRixRQUFRRyxJQUFJLENBQUNzQixlQUFlLENBQUNsQixNQUFNO1lBQzVDO1lBRUFMLE9BQU92QixlQUFlRyxJQUFJLEVBQUVtQyxxQkFBcUIsQ0FBQztZQUNsRFosVUFBVUMsT0FBTyxDQUFDLENBQUNULFVBQVVVO2dCQUMzQkwsT0FBT3ZCLGVBQWVHLElBQUksRUFBRW9DLHVCQUF1QixDQUNqRFgsUUFBUSxHQUNSVjtZQUVKO1FBQ0Y7UUFFQUQsR0FBRyxzQ0FBc0M7WUFDdkMsTUFBTWlDLG9CQUFvQjtnQkFDeEI7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7Z0JBQ0E7YUFDRDtZQUVEQSxrQkFBa0J2QixPQUFPLENBQUMsQ0FBQ1QsVUFBVVU7Z0JBQ25DLE1BQU1ULGlCQUF3QyxDQUFDLGlCQUFpQixFQUFFUyxPQUFPO2dCQUN6RTVCLGVBQWVHLElBQUksQ0FBQ2lCLGVBQWUsQ0FBQ0Q7Z0JBRXBDLE1BQU1FLFNBQVN0QixRQUFRdUIsT0FBTyxDQUFDSjtnQkFFL0JLLE9BQU9GLFFBQVFHLElBQUksQ0FBQ0w7Z0JBQ3BCSSxPQUFPdkIsZUFBZUcsSUFBSSxFQUFFc0Isb0JBQW9CLENBQUNQO1lBQ25EO1FBQ0Y7SUFDRjtBQUNGIn0=