312efbab07d5c83ca701c475102a4b7a
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _testing = require("@nestjs/testing");
const _hashservice = require("./hash.service");
const _hashStringuseCase = require("../../ports/in/hashString.useCase");
const _compareHashuseCase = require("../../ports/in/compareHash.useCase");
const _testsetup = require("../../../../test-setup");
describe('HashService', ()=>{
    let service;
    let hashStringUseCase;
    let compareHashUseCase;
    beforeAll(async ()=>{
        const mockHashStringUseCase = (0, _testsetup.createMockUseCase)();
        const mockCompareHashUseCase = (0, _testsetup.createMockUseCase)();
        const module = await _testing.Test.createTestingModule({
            providers: [
                _hashservice.HashService,
                {
                    provide: _hashStringuseCase.HashStringUseCase,
                    useValue: mockHashStringUseCase
                },
                {
                    provide: _compareHashuseCase.CompareHashUseCase,
                    useValue: mockCompareHashUseCase
                }
            ]
        }).compile();
        service = module.get(_hashservice.HashService);
        hashStringUseCase = module.get(_hashStringuseCase.HashStringUseCase);
        compareHashUseCase = module.get(_compareHashuseCase.CompareHashUseCase);
    });
    describe('hash', ()=>{
        it('should hash a password successfully', ()=>{
            const password = 'mySecretPassword123';
            const hashedPassword = 'hashedPassword123';
            hashStringUseCase.execute.mockReturnValue(hashedPassword);
            const result = service.hash(password);
            expect(result).toBe(hashedPassword);
            expect(hashStringUseCase.execute).toHaveBeenCalledWith(password);
        });
        it('should handle empty password', ()=>{
            const password = '';
            const hashedPassword = 'hashedEmptyString';
            hashStringUseCase.execute.mockReturnValue(hashedPassword);
            const result = service.hash(password);
            expect(result).toBe(hashedPassword);
            expect(hashStringUseCase.execute).toHaveBeenCalledWith(password);
        });
        it('should handle different password types', ()=>{
            const testCases = [
                {
                    password: 'Complex@Password123!',
                    expected: 'hashedComplex'
                },
                {
                    password: 'Ã Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«',
                    expected: 'hashedUnicode'
                },
                {
                    password: 'a'.repeat(100),
                    expected: 'hashedLong'
                }
            ];
            testCases.forEach(({ password, expected })=>{
                hashStringUseCase.execute.mockReturnValue(expected);
                const result = service.hash(password);
                expect(result).toBe(expected);
            });
        });
        it('should handle use case errors', ()=>{
            const password = 'testPassword';
            hashStringUseCase.execute.mockImplementation(()=>{
                throw new Error('Hashing failed');
            });
            expect(()=>service.hash(password)).toThrow('Hashing failed');
            expect(hashStringUseCase.execute).toHaveBeenCalledWith(password);
        });
        it('should handle null return from use case', ()=>{
            const password = 'testPassword';
            hashStringUseCase.execute.mockReturnValue(null);
            const result = service.hash(password);
            expect(result).toBeNull();
            expect(hashStringUseCase.execute).toHaveBeenCalledWith(password);
        });
        it('should handle undefined return from use case', ()=>{
            const password = 'testPassword';
            hashStringUseCase.execute.mockReturnValue(undefined);
            const result = service.hash(password);
            expect(result).toBeUndefined();
            expect(hashStringUseCase.execute).toHaveBeenCalledWith(password);
        });
    });
    describe('compare', ()=>{
        it('should compare password with hash successfully when they match', ()=>{
            const password = 'mySecretPassword123';
            const passwordWithHash = 'salt:hashedPassword123';
            compareHashUseCase.execute.mockReturnValue(true);
            const result = service.compare(password, passwordWithHash);
            expect(result).toBe(true);
            expect(compareHashUseCase.execute).toHaveBeenCalledWith({
                password,
                hash: passwordWithHash
            });
        });
        it('should compare password with hash successfully when they do not match', ()=>{
            const password = 'wrongPassword';
            const passwordWithHash = 'salt:hashedPassword123';
            compareHashUseCase.execute.mockReturnValue(false);
            const result = service.compare(password, passwordWithHash);
            expect(result).toBe(false);
            expect(compareHashUseCase.execute).toHaveBeenCalledWith({
                password,
                hash: passwordWithHash
            });
        });
        it('should handle empty password comparison', ()=>{
            const password = '';
            const passwordWithHash = 'salt:hashedPassword123';
            compareHashUseCase.execute.mockReturnValue(false);
            const result = service.compare(password, passwordWithHash);
            expect(result).toBe(false);
            expect(compareHashUseCase.execute).toHaveBeenCalledWith({
                password,
                hash: passwordWithHash
            });
        });
        it('should handle different password and hash formats', ()=>{
            const testCases = [
                {
                    password: 'simple',
                    hash: 'salt:hash',
                    expected: true
                },
                {
                    password: 'Complex@123!',
                    hash: 'longsalt:longhash',
                    expected: false
                },
                {
                    password: 'ðŸ”ðŸ”‘',
                    hash: 'special@salt:special#hash',
                    expected: true
                }
            ];
            testCases.forEach(({ password, hash, expected })=>{
                compareHashUseCase.execute.mockReturnValue(expected);
                const result = service.compare(password, hash);
                expect(result).toBe(expected);
            });
        });
        it('should handle use case errors in comparison', ()=>{
            const password = 'testPassword';
            const passwordWithHash = 'salt:hash';
            compareHashUseCase.execute.mockImplementation(()=>{
                throw new Error('Comparison failed');
            });
            expect(()=>service.compare(password, passwordWithHash)).toThrow('Comparison failed');
            expect(compareHashUseCase.execute).toHaveBeenCalledWith({
                password,
                hash: passwordWithHash
            });
        });
    });
    describe('integration scenarios', ()=>{
        it('should handle hash and compare workflow', ()=>{
            const originalPassword = 'mySecretPassword123';
            const hashedPassword = 'salt:hashedPassword123';
            const passwordWithHash = hashedPassword;
            hashStringUseCase.execute.mockReturnValue(hashedPassword);
            compareHashUseCase.execute.mockReturnValue(true);
            const hashResult = service.hash(originalPassword);
            const compareResult = service.compare(originalPassword, passwordWithHash);
            expect(hashResult).toBe(hashedPassword);
            expect(compareResult).toBe(true);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy95c3JhZWxtb3Jlbm8vRG9jdW1lbnRzL2NvZGVzL2ZhdGVjL3Nhbmd1ZS1zb2xpZGFyaW8vdXNlcnMtc2VydmljZS9zcmMvbW9kdWxlcy9IYXNoL2FwcGxpY2F0aW9uL2NvcmUvc2VydmljZS9oYXNoLnNlcnZpY2Uuc3BlYy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXN0LCBUZXN0aW5nTW9kdWxlIH0gZnJvbSAnQG5lc3Rqcy90ZXN0aW5nJztcbmltcG9ydCB7IEhhc2hTZXJ2aWNlIH0gZnJvbSAnLi9oYXNoLnNlcnZpY2UnO1xuaW1wb3J0IHsgSGFzaFN0cmluZ1VzZUNhc2UgfSBmcm9tICcuLi8uLi9wb3J0cy9pbi9oYXNoU3RyaW5nLnVzZUNhc2UnO1xuaW1wb3J0IHsgQ29tcGFyZUhhc2hVc2VDYXNlIH0gZnJvbSAnLi4vLi4vcG9ydHMvaW4vY29tcGFyZUhhc2gudXNlQ2FzZSc7XG5pbXBvcnQgeyBjcmVhdGVNb2NrVXNlQ2FzZSB9IGZyb20gJy4uLy4uLy4uLy4uL3Rlc3Qtc2V0dXAnO1xuXG5kZXNjcmliZSgnSGFzaFNlcnZpY2UnLCAoKSA9PiB7XG4gIGxldCBzZXJ2aWNlOiBIYXNoU2VydmljZTtcbiAgbGV0IGhhc2hTdHJpbmdVc2VDYXNlOiBqZXN0Lk1vY2tlZDxIYXNoU3RyaW5nVXNlQ2FzZT47XG4gIGxldCBjb21wYXJlSGFzaFVzZUNhc2U6IGplc3QuTW9ja2VkPENvbXBhcmVIYXNoVXNlQ2FzZT47XG5cbiAgYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2NrSGFzaFN0cmluZ1VzZUNhc2UgPSBjcmVhdGVNb2NrVXNlQ2FzZSgpO1xuICAgIGNvbnN0IG1vY2tDb21wYXJlSGFzaFVzZUNhc2UgPSBjcmVhdGVNb2NrVXNlQ2FzZSgpO1xuXG4gICAgY29uc3QgbW9kdWxlOiBUZXN0aW5nTW9kdWxlID0gYXdhaXQgVGVzdC5jcmVhdGVUZXN0aW5nTW9kdWxlKHtcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICBIYXNoU2VydmljZSxcbiAgICAgICAgeyBwcm92aWRlOiBIYXNoU3RyaW5nVXNlQ2FzZSwgdXNlVmFsdWU6IG1vY2tIYXNoU3RyaW5nVXNlQ2FzZSB9LFxuICAgICAgICB7IHByb3ZpZGU6IENvbXBhcmVIYXNoVXNlQ2FzZSwgdXNlVmFsdWU6IG1vY2tDb21wYXJlSGFzaFVzZUNhc2UgfSxcbiAgICAgIF0sXG4gICAgfSkuY29tcGlsZSgpO1xuXG4gICAgc2VydmljZSA9IG1vZHVsZS5nZXQ8SGFzaFNlcnZpY2U+KEhhc2hTZXJ2aWNlKTtcbiAgICBoYXNoU3RyaW5nVXNlQ2FzZSA9IG1vZHVsZS5nZXQoSGFzaFN0cmluZ1VzZUNhc2UpO1xuICAgIGNvbXBhcmVIYXNoVXNlQ2FzZSA9IG1vZHVsZS5nZXQoQ29tcGFyZUhhc2hVc2VDYXNlKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2hhc2gnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYXNoIGEgcGFzc3dvcmQgc3VjY2Vzc2Z1bGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSAnbXlTZWNyZXRQYXNzd29yZDEyMyc7XG4gICAgICBjb25zdCBoYXNoZWRQYXNzd29yZCA9ICdoYXNoZWRQYXNzd29yZDEyMyc7XG5cbiAgICAgIGhhc2hTdHJpbmdVc2VDYXNlLmV4ZWN1dGUubW9ja1JldHVyblZhbHVlKGhhc2hlZFBhc3N3b3JkKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gc2VydmljZS5oYXNoKHBhc3N3b3JkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShoYXNoZWRQYXNzd29yZCk7XG4gICAgICBleHBlY3QoaGFzaFN0cmluZ1VzZUNhc2UuZXhlY3V0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgocGFzc3dvcmQpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgcGFzc3dvcmQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXNzd29yZCA9ICcnO1xuICAgICAgY29uc3QgaGFzaGVkUGFzc3dvcmQgPSAnaGFzaGVkRW1wdHlTdHJpbmcnO1xuXG4gICAgICBoYXNoU3RyaW5nVXNlQ2FzZS5leGVjdXRlLm1vY2tSZXR1cm5WYWx1ZShoYXNoZWRQYXNzd29yZCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHNlcnZpY2UuaGFzaChwYXNzd29yZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoaGFzaGVkUGFzc3dvcmQpO1xuICAgICAgZXhwZWN0KGhhc2hTdHJpbmdVc2VDYXNlLmV4ZWN1dGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHBhc3N3b3JkKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRpZmZlcmVudCBwYXNzd29yZCB0eXBlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDYXNlcyA9IFtcbiAgICAgICAgeyBwYXNzd29yZDogJ0NvbXBsZXhAUGFzc3dvcmQxMjMhJywgZXhwZWN0ZWQ6ICdoYXNoZWRDb21wbGV4JyB9LFxuICAgICAgICB7IHBhc3N3b3JkOiAnw6DDocOiw6PDpMOlw6bDp8Oow6nDqsOrJywgZXhwZWN0ZWQ6ICdoYXNoZWRVbmljb2RlJyB9LFxuICAgICAgICB7IHBhc3N3b3JkOiAnYScucmVwZWF0KDEwMCksIGV4cGVjdGVkOiAnaGFzaGVkTG9uZycgfSxcbiAgICAgIF07XG5cbiAgICAgIHRlc3RDYXNlcy5mb3JFYWNoKCh7IHBhc3N3b3JkLCBleHBlY3RlZCB9KSA9PiB7XG4gICAgICAgIGhhc2hTdHJpbmdVc2VDYXNlLmV4ZWN1dGUubW9ja1JldHVyblZhbHVlKGV4cGVjdGVkKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2VydmljZS5oYXNoKHBhc3N3b3JkKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShleHBlY3RlZCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHVzZSBjYXNlIGVycm9ycycsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gJ3Rlc3RQYXNzd29yZCc7XG4gICAgICBoYXNoU3RyaW5nVXNlQ2FzZS5leGVjdXRlLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaGluZyBmYWlsZWQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QoKCkgPT4gc2VydmljZS5oYXNoKHBhc3N3b3JkKSkudG9UaHJvdygnSGFzaGluZyBmYWlsZWQnKTtcbiAgICAgIGV4cGVjdChoYXNoU3RyaW5nVXNlQ2FzZS5leGVjdXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChwYXNzd29yZCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBudWxsIHJldHVybiBmcm9tIHVzZSBjYXNlJywgKCkgPT4ge1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSAndGVzdFBhc3N3b3JkJztcbiAgICAgIGhhc2hTdHJpbmdVc2VDYXNlLmV4ZWN1dGUubW9ja1JldHVyblZhbHVlKG51bGwgYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gc2VydmljZS5oYXNoKHBhc3N3b3JkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChoYXNoU3RyaW5nVXNlQ2FzZS5leGVjdXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChwYXNzd29yZCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB1bmRlZmluZWQgcmV0dXJuIGZyb20gdXNlIGNhc2UnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXNzd29yZCA9ICd0ZXN0UGFzc3dvcmQnO1xuICAgICAgaGFzaFN0cmluZ1VzZUNhc2UuZXhlY3V0ZS5tb2NrUmV0dXJuVmFsdWUodW5kZWZpbmVkIGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHNlcnZpY2UuaGFzaChwYXNzd29yZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgIGV4cGVjdChoYXNoU3RyaW5nVXNlQ2FzZS5leGVjdXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChwYXNzd29yZCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjb21wYXJlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY29tcGFyZSBwYXNzd29yZCB3aXRoIGhhc2ggc3VjY2Vzc2Z1bGx5IHdoZW4gdGhleSBtYXRjaCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gJ215U2VjcmV0UGFzc3dvcmQxMjMnO1xuICAgICAgY29uc3QgcGFzc3dvcmRXaXRoSGFzaDogYCR7c3RyaW5nfToke3N0cmluZ31gID0gJ3NhbHQ6aGFzaGVkUGFzc3dvcmQxMjMnO1xuXG4gICAgICBjb21wYXJlSGFzaFVzZUNhc2UuZXhlY3V0ZS5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHNlcnZpY2UuY29tcGFyZShwYXNzd29yZCwgcGFzc3dvcmRXaXRoSGFzaCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoY29tcGFyZUhhc2hVc2VDYXNlLmV4ZWN1dGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgIGhhc2g6IHBhc3N3b3JkV2l0aEhhc2gsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY29tcGFyZSBwYXNzd29yZCB3aXRoIGhhc2ggc3VjY2Vzc2Z1bGx5IHdoZW4gdGhleSBkbyBub3QgbWF0Y2gnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXNzd29yZCA9ICd3cm9uZ1Bhc3N3b3JkJztcbiAgICAgIGNvbnN0IHBhc3N3b3JkV2l0aEhhc2g6IGAke3N0cmluZ306JHtzdHJpbmd9YCA9ICdzYWx0Omhhc2hlZFBhc3N3b3JkMTIzJztcblxuICAgICAgY29tcGFyZUhhc2hVc2VDYXNlLmV4ZWN1dGUubW9ja1JldHVyblZhbHVlKGZhbHNlKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gc2VydmljZS5jb21wYXJlKHBhc3N3b3JkLCBwYXNzd29yZFdpdGhIYXNoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoY29tcGFyZUhhc2hVc2VDYXNlLmV4ZWN1dGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgIGhhc2g6IHBhc3N3b3JkV2l0aEhhc2gsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IHBhc3N3b3JkIGNvbXBhcmlzb24nLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXNzd29yZCA9ICcnO1xuICAgICAgY29uc3QgcGFzc3dvcmRXaXRoSGFzaDogYCR7c3RyaW5nfToke3N0cmluZ31gID0gJ3NhbHQ6aGFzaGVkUGFzc3dvcmQxMjMnO1xuXG4gICAgICBjb21wYXJlSGFzaFVzZUNhc2UuZXhlY3V0ZS5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBzZXJ2aWNlLmNvbXBhcmUocGFzc3dvcmQsIHBhc3N3b3JkV2l0aEhhc2gpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChjb21wYXJlSGFzaFVzZUNhc2UuZXhlY3V0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgaGFzaDogcGFzc3dvcmRXaXRoSGFzaCxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGlmZmVyZW50IHBhc3N3b3JkIGFuZCBoYXNoIGZvcm1hdHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0Q2FzZXMgPSBbXG4gICAgICAgIHsgcGFzc3dvcmQ6ICdzaW1wbGUnLCBoYXNoOiAnc2FsdDpoYXNoJyBhcyBjb25zdCwgZXhwZWN0ZWQ6IHRydWUgfSxcbiAgICAgICAge1xuICAgICAgICAgIHBhc3N3b3JkOiAnQ29tcGxleEAxMjMhJyxcbiAgICAgICAgICBoYXNoOiAnbG9uZ3NhbHQ6bG9uZ2hhc2gnIGFzIGNvbnN0LFxuICAgICAgICAgIGV4cGVjdGVkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHBhc3N3b3JkOiAn8J+UkPCflJEnLFxuICAgICAgICAgIGhhc2g6ICdzcGVjaWFsQHNhbHQ6c3BlY2lhbCNoYXNoJyBhcyBjb25zdCxcbiAgICAgICAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIHRlc3RDYXNlcy5mb3JFYWNoKCh7IHBhc3N3b3JkLCBoYXNoLCBleHBlY3RlZCB9KSA9PiB7XG4gICAgICAgIGNvbXBhcmVIYXNoVXNlQ2FzZS5leGVjdXRlLm1vY2tSZXR1cm5WYWx1ZShleHBlY3RlZCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNlcnZpY2UuY29tcGFyZShwYXNzd29yZCwgaGFzaCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZXhwZWN0ZWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB1c2UgY2FzZSBlcnJvcnMgaW4gY29tcGFyaXNvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gJ3Rlc3RQYXNzd29yZCc7XG4gICAgICBjb25zdCBwYXNzd29yZFdpdGhIYXNoOiBgJHtzdHJpbmd9OiR7c3RyaW5nfWAgPSAnc2FsdDpoYXNoJztcblxuICAgICAgY29tcGFyZUhhc2hVc2VDYXNlLmV4ZWN1dGUubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wYXJpc29uIGZhaWxlZCcpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdCgoKSA9PiBzZXJ2aWNlLmNvbXBhcmUocGFzc3dvcmQsIHBhc3N3b3JkV2l0aEhhc2gpKS50b1Rocm93KFxuICAgICAgICAnQ29tcGFyaXNvbiBmYWlsZWQnLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChjb21wYXJlSGFzaFVzZUNhc2UuZXhlY3V0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgaGFzaDogcGFzc3dvcmRXaXRoSGFzaCxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdpbnRlZ3JhdGlvbiBzY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgaGFzaCBhbmQgY29tcGFyZSB3b3JrZmxvdycsICgpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsUGFzc3dvcmQgPSAnbXlTZWNyZXRQYXNzd29yZDEyMyc7XG4gICAgICBjb25zdCBoYXNoZWRQYXNzd29yZCA9ICdzYWx0Omhhc2hlZFBhc3N3b3JkMTIzJztcbiAgICAgIGNvbnN0IHBhc3N3b3JkV2l0aEhhc2g6IGAke3N0cmluZ306JHtzdHJpbmd9YCA9IGhhc2hlZFBhc3N3b3JkIGFzIGAke3N0cmluZ306JHtzdHJpbmd9YDtcblxuICAgICAgaGFzaFN0cmluZ1VzZUNhc2UuZXhlY3V0ZS5tb2NrUmV0dXJuVmFsdWUoaGFzaGVkUGFzc3dvcmQpO1xuICAgICAgY29tcGFyZUhhc2hVc2VDYXNlLmV4ZWN1dGUubW9ja1JldHVyblZhbHVlKHRydWUpO1xuXG4gICAgICBjb25zdCBoYXNoUmVzdWx0ID0gc2VydmljZS5oYXNoKG9yaWdpbmFsUGFzc3dvcmQpO1xuICAgICAgY29uc3QgY29tcGFyZVJlc3VsdCA9IHNlcnZpY2UuY29tcGFyZShvcmlnaW5hbFBhc3N3b3JkLCBwYXNzd29yZFdpdGhIYXNoKTtcblxuICAgICAgZXhwZWN0KGhhc2hSZXN1bHQpLnRvQmUoaGFzaGVkUGFzc3dvcmQpO1xuICAgICAgZXhwZWN0KGNvbXBhcmVSZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJzZXJ2aWNlIiwiaGFzaFN0cmluZ1VzZUNhc2UiLCJjb21wYXJlSGFzaFVzZUNhc2UiLCJiZWZvcmVBbGwiLCJtb2NrSGFzaFN0cmluZ1VzZUNhc2UiLCJjcmVhdGVNb2NrVXNlQ2FzZSIsIm1vY2tDb21wYXJlSGFzaFVzZUNhc2UiLCJtb2R1bGUiLCJUZXN0IiwiY3JlYXRlVGVzdGluZ01vZHVsZSIsInByb3ZpZGVycyIsIkhhc2hTZXJ2aWNlIiwicHJvdmlkZSIsIkhhc2hTdHJpbmdVc2VDYXNlIiwidXNlVmFsdWUiLCJDb21wYXJlSGFzaFVzZUNhc2UiLCJjb21waWxlIiwiZ2V0IiwiaXQiLCJwYXNzd29yZCIsImhhc2hlZFBhc3N3b3JkIiwiZXhlY3V0ZSIsIm1vY2tSZXR1cm5WYWx1ZSIsInJlc3VsdCIsImhhc2giLCJleHBlY3QiLCJ0b0JlIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ0ZXN0Q2FzZXMiLCJleHBlY3RlZCIsInJlcGVhdCIsImZvckVhY2giLCJtb2NrSW1wbGVtZW50YXRpb24iLCJFcnJvciIsInRvVGhyb3ciLCJ0b0JlTnVsbCIsInVuZGVmaW5lZCIsInRvQmVVbmRlZmluZWQiLCJwYXNzd29yZFdpdGhIYXNoIiwiY29tcGFyZSIsIm9yaWdpbmFsUGFzc3dvcmQiLCJoYXNoUmVzdWx0IiwiY29tcGFyZVJlc3VsdCJdLCJtYXBwaW5ncyI6Ijs7Ozt5QkFBb0M7NkJBQ1I7bUNBQ007b0NBQ0M7MkJBQ0Q7QUFFbENBLFNBQVMsZUFBZTtJQUN0QixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFFSkMsVUFBVTtRQUNSLE1BQU1DLHdCQUF3QkMsSUFBQUEsNEJBQWlCO1FBQy9DLE1BQU1DLHlCQUF5QkQsSUFBQUEsNEJBQWlCO1FBRWhELE1BQU1FLFNBQXdCLE1BQU1DLGFBQUksQ0FBQ0MsbUJBQW1CLENBQUM7WUFDM0RDLFdBQVc7Z0JBQ1RDLHdCQUFXO2dCQUNYO29CQUFFQyxTQUFTQyxvQ0FBaUI7b0JBQUVDLFVBQVVWO2dCQUFzQjtnQkFDOUQ7b0JBQUVRLFNBQVNHLHNDQUFrQjtvQkFBRUQsVUFBVVI7Z0JBQXVCO2FB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