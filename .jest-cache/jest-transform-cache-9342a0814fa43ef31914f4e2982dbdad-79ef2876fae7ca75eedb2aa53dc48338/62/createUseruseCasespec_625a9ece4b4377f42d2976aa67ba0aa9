9b407329b6b362c321315781906f82cb
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _testing = require("@nestjs/testing");
const _createUseruseCase = require("./createUser.useCase");
const _getUserByEmailuseCase = require("./getUserByEmail.useCase");
const _constants = require("../../../../constants");
const _errorsenum = require("../../../core/errors/errors.enum");
const _resulttypes = require("../../../types/result.types");
const _testsetup = require("../../../../test-setup");
describe('CreateUserUseCase', ()=>{
    let useCase;
    let userRepository;
    let getUserByEmailUseCase;
    beforeAll(async ()=>{
        const mockUserRepository = (0, _testsetup.createMockRepository)();
        const mockGetUserByEmailUseCase = (0, _testsetup.createMockUseCase)();
        const module = await _testing.Test.createTestingModule({
            providers: [
                _createUseruseCase.CreateUserUseCase,
                {
                    provide: _constants.USERS_REPOSITORY,
                    useValue: mockUserRepository
                },
                {
                    provide: _getUserByEmailuseCase.GetUserByEmailUseCase,
                    useValue: mockGetUserByEmailUseCase
                }
            ]
        }).compile();
        useCase = module.get(_createUseruseCase.CreateUserUseCase);
        userRepository = module.get(_constants.USERS_REPOSITORY);
        getUserByEmailUseCase = module.get(_getUserByEmailuseCase.GetUserByEmailUseCase);
    });
    describe('execute', ()=>{
        const validUserData = {
            email: 'test@example.com',
            password: 'hashedPassword123',
            name: 'John Doe',
            city: 'São Paulo',
            uf: 'SP',
            zipcode: '01234-567',
            personType: 'DONOR'
        };
        it('should create a new user successfully when email does not exist', async ()=>{
            const savedUser = {
                id: '123e4567-e89b-12d3-a456-426614174000',
                ...validUserData
            };
            getUserByEmailUseCase.execute.mockResolvedValue(_resulttypes.ResultFactory.failure(_errorsenum.ErrorsEnum.UserNotFound));
            userRepository.save.mockResolvedValue(savedUser);
            const result = await useCase.execute(validUserData);
            expect(result.isSuccess).toBe(true);
            expect(result.value).toEqual(savedUser);
            expect(getUserByEmailUseCase.execute).toHaveBeenCalledWith(validUserData.email);
            expect(userRepository.save).toHaveBeenCalledWith(validUserData);
        });
        it('should return failure when user with email already exists', async ()=>{
            const existingUser = {
                id: '987e6543-e21b-34d5-a678-426614174111',
                ...validUserData
            };
            getUserByEmailUseCase.execute.mockResolvedValue(_resulttypes.ResultFactory.success(existingUser));
            const result = await useCase.execute(validUserData);
            expect(result.isSuccess).toBe(false);
            expect(result.error).toBe(_errorsenum.ErrorsEnum.UserAlreadyExists);
            expect(getUserByEmailUseCase.execute).toHaveBeenCalledWith(validUserData.email);
            expect(userRepository.save).not.toHaveBeenCalled();
        });
        it('should handle different person types', async ()=>{
            const donorUser = {
                ...validUserData,
                personType: 'DONOR'
            };
            const companyUser = {
                ...validUserData,
                personType: 'COMPANY',
                email: 'company@example.com'
            };
            getUserByEmailUseCase.execute.mockResolvedValue(_resulttypes.ResultFactory.failure(_errorsenum.ErrorsEnum.UserNotFound));
            const savedDonor = {
                id: '123',
                ...donorUser
            };
            const savedCompany = {
                id: '456',
                ...companyUser
            };
            userRepository.save.mockResolvedValueOnce(savedDonor).mockResolvedValueOnce(savedCompany);
            const donorResult = await useCase.execute(donorUser);
            const companyResult = await useCase.execute(companyUser);
            expect(donorResult.isSuccess).toBe(true);
            expect(donorResult.value?.personType).toBe('DONOR');
            expect(companyResult.isSuccess).toBe(true);
            expect(companyResult.value?.personType).toBe('COMPANY');
        });
        it('should handle user creation without optional fields', async ()=>{
            const minimalUserData = {
                email: 'minimal@example.com',
                name: 'Minimal User',
                city: 'São Paulo',
                uf: 'SP',
                personType: 'DONOR'
            };
            const savedUser = {
                id: '123e4567-e89b-12d3-a456-426614174000',
                ...minimalUserData
            };
            getUserByEmailUseCase.execute.mockResolvedValue(_resulttypes.ResultFactory.failure(_errorsenum.ErrorsEnum.UserNotFound));
            userRepository.save.mockResolvedValue(savedUser);
            const result = await useCase.execute(minimalUserData);
            expect(result.isSuccess).toBe(true);
            expect(result.value).toEqual(savedUser);
            expect(result.value?.password).toBeUndefined();
            expect(result.value?.zipcode).toBeUndefined();
        });
        it('should handle different data formats', async ()=>{
            const testCases = [
                {
                    uf: 'SP',
                    email: 'test-sp@example.com',
                    zipcode: '01234-567'
                },
                {
                    uf: 'RJ',
                    email: 'user.name@domain.co.uk',
                    zipcode: '01234567'
                }
            ];
            getUserByEmailUseCase.execute.mockResolvedValue(_resulttypes.ResultFactory.failure(_errorsenum.ErrorsEnum.UserNotFound));
            for (const testCase of testCases){
                const userData = {
                    ...validUserData,
                    ...testCase
                };
                const savedUser = {
                    id: 'test-id',
                    ...userData
                };
                userRepository.save.mockResolvedValue(savedUser);
                const result = await useCase.execute(userData);
                expect(result.isSuccess).toBe(true);
                expect(result.value?.uf).toBe(testCase.uf);
                expect(result.value?.email).toBe(testCase.email);
            }
        });
        it('should handle repository errors gracefully', async ()=>{
            getUserByEmailUseCase.execute.mockResolvedValue(_resulttypes.ResultFactory.failure(_errorsenum.ErrorsEnum.UserNotFound));
            userRepository.save.mockRejectedValue(new Error('Database connection failed'));
            await expect(useCase.execute(validUserData)).rejects.toThrow('Database connection failed');
            expect(getUserByEmailUseCase.execute).toHaveBeenCalledWith(validUserData.email);
        });
        it('should handle getUserByEmailUseCase errors', async ()=>{
            getUserByEmailUseCase.execute.mockRejectedValue(new Error('Email service unavailable'));
            await expect(useCase.execute(validUserData)).rejects.toThrow('Email service unavailable');
            expect(userRepository.save).not.toHaveBeenCalled();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy95c3JhZWxtb3Jlbm8vRG9jdW1lbnRzL2NvZGVzL2ZhdGVjL3Nhbmd1ZS1zb2xpZGFyaW8vdXNlcnMtc2VydmljZS9zcmMvYXBwbGljYXRpb24vcG9ydHMvaW4vdXNlci9jcmVhdGVVc2VyLnVzZUNhc2Uuc3BlYy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXN0LCBUZXN0aW5nTW9kdWxlIH0gZnJvbSAnQG5lc3Rqcy90ZXN0aW5nJztcbmltcG9ydCB7IENyZWF0ZVVzZXJVc2VDYXNlIH0gZnJvbSAnLi9jcmVhdGVVc2VyLnVzZUNhc2UnO1xuaW1wb3J0IHsgR2V0VXNlckJ5RW1haWxVc2VDYXNlIH0gZnJvbSAnLi9nZXRVc2VyQnlFbWFpbC51c2VDYXNlJztcbmltcG9ydCB7IFVzZXJSZXBvc2l0b3J5UG9ydCB9IGZyb20gJy4uLy4uL291dC91c2Vycy1yZXBvc2l0b3J5LnBvcnQnO1xuaW1wb3J0IHsgVVNFUlNfUkVQT1NJVE9SWSB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi4vLi4vLi4vY29yZS9kb21haW4vdXNlci5lbnRpdHknO1xuaW1wb3J0IHsgRXJyb3JzRW51bSB9IGZyb20gJy4uLy4uLy4uL2NvcmUvZXJyb3JzL2Vycm9ycy5lbnVtJztcbmltcG9ydCB7IFJlc3VsdEZhY3RvcnkgfSBmcm9tICcuLi8uLi8uLi90eXBlcy9yZXN1bHQudHlwZXMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlTW9ja1JlcG9zaXRvcnksXG4gIGNyZWF0ZU1vY2tVc2VDYXNlLFxufSBmcm9tICcuLi8uLi8uLi8uLi90ZXN0LXNldHVwJztcblxuZGVzY3JpYmUoJ0NyZWF0ZVVzZXJVc2VDYXNlJywgKCkgPT4ge1xuICBsZXQgdXNlQ2FzZTogQ3JlYXRlVXNlclVzZUNhc2U7XG4gIGxldCB1c2VyUmVwb3NpdG9yeTogamVzdC5Nb2NrZWQ8VXNlclJlcG9zaXRvcnlQb3J0PjtcbiAgbGV0IGdldFVzZXJCeUVtYWlsVXNlQ2FzZTogamVzdC5Nb2NrZWQ8R2V0VXNlckJ5RW1haWxVc2VDYXNlPjtcblxuICBiZWZvcmVBbGwoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tVc2VyUmVwb3NpdG9yeSA9IGNyZWF0ZU1vY2tSZXBvc2l0b3J5KCk7XG4gICAgY29uc3QgbW9ja0dldFVzZXJCeUVtYWlsVXNlQ2FzZSA9IGNyZWF0ZU1vY2tVc2VDYXNlKCk7XG5cbiAgICBjb25zdCBtb2R1bGU6IFRlc3RpbmdNb2R1bGUgPSBhd2FpdCBUZXN0LmNyZWF0ZVRlc3RpbmdNb2R1bGUoe1xuICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIENyZWF0ZVVzZXJVc2VDYXNlLFxuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogVVNFUlNfUkVQT1NJVE9SWSxcbiAgICAgICAgICB1c2VWYWx1ZTogbW9ja1VzZXJSZXBvc2l0b3J5LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogR2V0VXNlckJ5RW1haWxVc2VDYXNlLFxuICAgICAgICAgIHVzZVZhbHVlOiBtb2NrR2V0VXNlckJ5RW1haWxVc2VDYXNlLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9KS5jb21waWxlKCk7XG5cbiAgICB1c2VDYXNlID0gbW9kdWxlLmdldDxDcmVhdGVVc2VyVXNlQ2FzZT4oQ3JlYXRlVXNlclVzZUNhc2UpO1xuICAgIHVzZXJSZXBvc2l0b3J5ID0gbW9kdWxlLmdldChVU0VSU19SRVBPU0lUT1JZKTtcbiAgICBnZXRVc2VyQnlFbWFpbFVzZUNhc2UgPSBtb2R1bGUuZ2V0KEdldFVzZXJCeUVtYWlsVXNlQ2FzZSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdleGVjdXRlJywgKCkgPT4ge1xuICAgIGNvbnN0IHZhbGlkVXNlckRhdGE6IE9taXQ8VXNlciwgJ2lkJz4gPSB7XG4gICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgcGFzc3dvcmQ6ICdoYXNoZWRQYXNzd29yZDEyMycsXG4gICAgICBuYW1lOiAnSm9obiBEb2UnLFxuICAgICAgY2l0eTogJ1PDo28gUGF1bG8nLFxuICAgICAgdWY6ICdTUCcsXG4gICAgICB6aXBjb2RlOiAnMDEyMzQtNTY3JyxcbiAgICAgIHBlcnNvblR5cGU6ICdET05PUicsXG4gICAgfTtcblxuICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgbmV3IHVzZXIgc3VjY2Vzc2Z1bGx5IHdoZW4gZW1haWwgZG9lcyBub3QgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzYXZlZFVzZXI6IFVzZXIgPSB7XG4gICAgICAgIGlkOiAnMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAwJyxcbiAgICAgICAgLi4udmFsaWRVc2VyRGF0YSxcbiAgICAgIH07XG5cbiAgICAgIGdldFVzZXJCeUVtYWlsVXNlQ2FzZS5leGVjdXRlLm1vY2tSZXNvbHZlZFZhbHVlKFxuICAgICAgICBSZXN1bHRGYWN0b3J5LmZhaWx1cmUoRXJyb3JzRW51bS5Vc2VyTm90Rm91bmQpLFxuICAgICAgKTtcbiAgICAgIHVzZXJSZXBvc2l0b3J5LnNhdmUubW9ja1Jlc29sdmVkVmFsdWUoc2F2ZWRVc2VyKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXNlQ2FzZS5leGVjdXRlKHZhbGlkVXNlckRhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudmFsdWUpLnRvRXF1YWwoc2F2ZWRVc2VyKTtcbiAgICAgIGV4cGVjdChnZXRVc2VyQnlFbWFpbFVzZUNhc2UuZXhlY3V0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIHZhbGlkVXNlckRhdGEuZW1haWwsXG4gICAgICApO1xuICAgICAgZXhwZWN0KHVzZXJSZXBvc2l0b3J5LnNhdmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHZhbGlkVXNlckRhdGEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFpbHVyZSB3aGVuIHVzZXIgd2l0aCBlbWFpbCBhbHJlYWR5IGV4aXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nVXNlcjogVXNlciA9IHtcbiAgICAgICAgaWQ6ICc5ODdlNjU0My1lMjFiLTM0ZDUtYTY3OC00MjY2MTQxNzQxMTEnLFxuICAgICAgICAuLi52YWxpZFVzZXJEYXRhLFxuICAgICAgfTtcblxuICAgICAgZ2V0VXNlckJ5RW1haWxVc2VDYXNlLmV4ZWN1dGUubW9ja1Jlc29sdmVkVmFsdWUoXG4gICAgICAgIFJlc3VsdEZhY3Rvcnkuc3VjY2VzcyhleGlzdGluZ1VzZXIpLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXNlQ2FzZS5leGVjdXRlKHZhbGlkVXNlckRhdGEpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmlzU3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlKEVycm9yc0VudW0uVXNlckFscmVhZHlFeGlzdHMpO1xuICAgICAgZXhwZWN0KGdldFVzZXJCeUVtYWlsVXNlQ2FzZS5leGVjdXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgdmFsaWRVc2VyRGF0YS5lbWFpbCxcbiAgICAgICk7XG4gICAgICBleHBlY3QodXNlclJlcG9zaXRvcnkuc2F2ZSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRpZmZlcmVudCBwZXJzb24gdHlwZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkb25vclVzZXI6IE9taXQ8VXNlciwgJ2lkJz4gPSB7XG4gICAgICAgIC4uLnZhbGlkVXNlckRhdGEsXG4gICAgICAgIHBlcnNvblR5cGU6ICdET05PUicsXG4gICAgICB9O1xuICAgICAgY29uc3QgY29tcGFueVVzZXI6IE9taXQ8VXNlciwgJ2lkJz4gPSB7XG4gICAgICAgIC4uLnZhbGlkVXNlckRhdGEsXG4gICAgICAgIHBlcnNvblR5cGU6ICdDT01QQU5ZJyxcbiAgICAgICAgZW1haWw6ICdjb21wYW55QGV4YW1wbGUuY29tJyxcbiAgICAgIH07XG5cbiAgICAgIGdldFVzZXJCeUVtYWlsVXNlQ2FzZS5leGVjdXRlLm1vY2tSZXNvbHZlZFZhbHVlKFxuICAgICAgICBSZXN1bHRGYWN0b3J5LmZhaWx1cmUoRXJyb3JzRW51bS5Vc2VyTm90Rm91bmQpLFxuICAgICAgKTtcblxuICAgICAgY29uc3Qgc2F2ZWREb25vcjogVXNlciA9IHsgaWQ6ICcxMjMnLCAuLi5kb25vclVzZXIgfTtcbiAgICAgIGNvbnN0IHNhdmVkQ29tcGFueTogVXNlciA9IHsgaWQ6ICc0NTYnLCAuLi5jb21wYW55VXNlciB9O1xuXG4gICAgICB1c2VyUmVwb3NpdG9yeS5zYXZlXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoc2F2ZWREb25vcilcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZShzYXZlZENvbXBhbnkpO1xuXG4gICAgICBjb25zdCBkb25vclJlc3VsdCA9IGF3YWl0IHVzZUNhc2UuZXhlY3V0ZShkb25vclVzZXIpO1xuICAgICAgY29uc3QgY29tcGFueVJlc3VsdCA9IGF3YWl0IHVzZUNhc2UuZXhlY3V0ZShjb21wYW55VXNlcik7XG5cbiAgICAgIGV4cGVjdChkb25vclJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoZG9ub3JSZXN1bHQudmFsdWU/LnBlcnNvblR5cGUpLnRvQmUoJ0RPTk9SJyk7XG4gICAgICBleHBlY3QoY29tcGFueVJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoY29tcGFueVJlc3VsdC52YWx1ZT8ucGVyc29uVHlwZSkudG9CZSgnQ09NUEFOWScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdXNlciBjcmVhdGlvbiB3aXRob3V0IG9wdGlvbmFsIGZpZWxkcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1pbmltYWxVc2VyRGF0YTogT21pdDxVc2VyLCAnaWQnPiA9IHtcbiAgICAgICAgZW1haWw6ICdtaW5pbWFsQGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ01pbmltYWwgVXNlcicsXG4gICAgICAgIGNpdHk6ICdTw6NvIFBhdWxvJyxcbiAgICAgICAgdWY6ICdTUCcsXG4gICAgICAgIHBlcnNvblR5cGU6ICdET05PUicsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzYXZlZFVzZXI6IFVzZXIgPSB7XG4gICAgICAgIGlkOiAnMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjE0MTc0MDAwJyxcbiAgICAgICAgLi4ubWluaW1hbFVzZXJEYXRhLFxuICAgICAgfTtcblxuICAgICAgZ2V0VXNlckJ5RW1haWxVc2VDYXNlLmV4ZWN1dGUubW9ja1Jlc29sdmVkVmFsdWUoXG4gICAgICAgIFJlc3VsdEZhY3RvcnkuZmFpbHVyZShFcnJvcnNFbnVtLlVzZXJOb3RGb3VuZCksXG4gICAgICApO1xuICAgICAgdXNlclJlcG9zaXRvcnkuc2F2ZS5tb2NrUmVzb2x2ZWRWYWx1ZShzYXZlZFVzZXIpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1c2VDYXNlLmV4ZWN1dGUobWluaW1hbFVzZXJEYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnZhbHVlKS50b0VxdWFsKHNhdmVkVXNlcik7XG4gICAgICBleHBlY3QocmVzdWx0LnZhbHVlPy5wYXNzd29yZCkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZT8uemlwY29kZSkudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGlmZmVyZW50IGRhdGEgZm9ybWF0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RDYXNlcyA9IFtcbiAgICAgICAgeyB1ZjogJ1NQJywgZW1haWw6ICd0ZXN0LXNwQGV4YW1wbGUuY29tJywgemlwY29kZTogJzAxMjM0LTU2NycgfSxcbiAgICAgICAgeyB1ZjogJ1JKJywgZW1haWw6ICd1c2VyLm5hbWVAZG9tYWluLmNvLnVrJywgemlwY29kZTogJzAxMjM0NTY3JyB9LFxuICAgICAgXTtcblxuICAgICAgZ2V0VXNlckJ5RW1haWxVc2VDYXNlLmV4ZWN1dGUubW9ja1Jlc29sdmVkVmFsdWUoXG4gICAgICAgIFJlc3VsdEZhY3RvcnkuZmFpbHVyZShFcnJvcnNFbnVtLlVzZXJOb3RGb3VuZCksXG4gICAgICApO1xuXG4gICAgICBmb3IgKGNvbnN0IHRlc3RDYXNlIG9mIHRlc3RDYXNlcykge1xuICAgICAgICBjb25zdCB1c2VyRGF0YTogT21pdDxVc2VyLCAnaWQnPiA9IHsgLi4udmFsaWRVc2VyRGF0YSwgLi4udGVzdENhc2UgfTtcbiAgICAgICAgY29uc3Qgc2F2ZWRVc2VyOiBVc2VyID0geyBpZDogJ3Rlc3QtaWQnLCAuLi51c2VyRGF0YSB9O1xuICAgICAgICB1c2VyUmVwb3NpdG9yeS5zYXZlLm1vY2tSZXNvbHZlZFZhbHVlKHNhdmVkVXNlcik7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXNlQ2FzZS5leGVjdXRlKHVzZXJEYXRhKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWx1ZT8udWYpLnRvQmUodGVzdENhc2UudWYpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbHVlPy5lbWFpbCkudG9CZSh0ZXN0Q2FzZS5lbWFpbCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByZXBvc2l0b3J5IGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgZ2V0VXNlckJ5RW1haWxVc2VDYXNlLmV4ZWN1dGUubW9ja1Jlc29sdmVkVmFsdWUoXG4gICAgICAgIFJlc3VsdEZhY3RvcnkuZmFpbHVyZShFcnJvcnNFbnVtLlVzZXJOb3RGb3VuZCksXG4gICAgICApO1xuICAgICAgdXNlclJlcG9zaXRvcnkuc2F2ZS5tb2NrUmVqZWN0ZWRWYWx1ZShcbiAgICAgICAgbmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpLFxuICAgICAgKTtcblxuICAgICAgYXdhaXQgZXhwZWN0KHVzZUNhc2UuZXhlY3V0ZSh2YWxpZFVzZXJEYXRhKSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChnZXRVc2VyQnlFbWFpbFVzZUNhc2UuZXhlY3V0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIHZhbGlkVXNlckRhdGEuZW1haWwsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZ2V0VXNlckJ5RW1haWxVc2VDYXNlIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGdldFVzZXJCeUVtYWlsVXNlQ2FzZS5leGVjdXRlLm1vY2tSZWplY3RlZFZhbHVlKFxuICAgICAgICBuZXcgRXJyb3IoJ0VtYWlsIHNlcnZpY2UgdW5hdmFpbGFibGUnKSxcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdCh1c2VDYXNlLmV4ZWN1dGUodmFsaWRVc2VyRGF0YSkpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgJ0VtYWlsIHNlcnZpY2UgdW5hdmFpbGFibGUnLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdCh1c2VyUmVwb3NpdG9yeS5zYXZlKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImRlc2NyaWJlIiwidXNlQ2FzZSIsInVzZXJSZXBvc2l0b3J5IiwiZ2V0VXNlckJ5RW1haWxVc2VDYXNlIiwiYmVmb3JlQWxsIiwibW9ja1VzZXJSZXBvc2l0b3J5IiwiY3JlYXRlTW9ja1JlcG9zaXRvcnkiLCJtb2NrR2V0VXNlckJ5RW1haWxVc2VDYXNlIiwiY3JlYXRlTW9ja1VzZUNhc2UiLCJtb2R1bGUiLCJUZXN0IiwiY3JlYXRlVGVzdGluZ01vZHVsZSIsInByb3ZpZGVycyIsIkNyZWF0ZVVzZXJVc2VDYXNlIiwicHJvdmlkZSIsIlVTRVJTX1JFUE9TSVRPUlkiLCJ1c2VWYWx1ZSIsIkdldFVzZXJCeUVtYWlsVXNlQ2FzZSIsImNvbXBpbGUiLCJnZXQiLCJ2YWxpZFVzZXJEYXRhIiwiZW1haWwiLCJwYXNzd29yZCIsIm5hbWUiLCJjaXR5IiwidWYiLCJ6aXBjb2RlIiwicGVyc29uVHlwZSIsIml0Iiwic2F2ZWRVc2VyIiwiaWQiLCJleGVjdXRlIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJSZXN1bHRGYWN0b3J5IiwiZmFpbHVyZSIsIkVycm9yc0VudW0iLCJVc2VyTm90Rm91bmQiLCJzYXZlIiwicmVzdWx0IiwiZXhwZWN0IiwiaXNTdWNjZXNzIiwidG9CZSIsInZhbHVlIiwidG9FcXVhbCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwiZXhpc3RpbmdVc2VyIiwic3VjY2VzcyIsImVycm9yIiwiVXNlckFscmVhZHlFeGlzdHMiLCJub3QiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwiZG9ub3JVc2VyIiwiY29tcGFueVVzZXIiLCJzYXZlZERvbm9yIiwic2F2ZWRDb21wYW55IiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwiZG9ub3JSZXN1bHQiLCJjb21wYW55UmVzdWx0IiwibWluaW1hbFVzZXJEYXRhIiwidG9CZVVuZGVmaW5lZCIsInRlc3RDYXNlcyIsInRlc3RDYXNlIiwidXNlckRhdGEiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIiwicmVqZWN0cyIsInRvVGhyb3ciXSwibWFwcGluZ3MiOiI7Ozs7eUJBQW9DO21DQUNGO3VDQUNJOzJCQUVMOzRCQUVOOzZCQUNHOzJCQUl2QjtBQUVQQSxTQUFTLHFCQUFxQjtJQUM1QixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFFSkMsVUFB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